<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>LeNet-5</title>
      <link href="/2020/02/08/LeNet-5/"/>
      <url>/2020/02/08/LeNet-5/</url>
      
        <content type="html"><![CDATA[<h3 id="模型介绍"><a href="#模型介绍" class="headerlink" title="模型介绍"></a>模型介绍</h3><p>​    LeNet-5是由$LeCun$ 提出的一种用于识别手写数字和机器印刷字符的卷积神经网络（Convolutional Neural Network，CNN）$^{[1]}$，其命名来源于作者$LeCun$的名字，5则是其研究成果的代号，在LeNet-5之前还有LeNet-4和LeNet-1鲜为人知。LeNet-5阐述了图像中像素特征之间的相关性能够由参数共享的卷积操作所提取，同时使用卷积、下采样（池化）和非线性映射这样的组合结构，是当前流行的大多数深度图像识别网络的基础。</p><h3 id="模型结构"><a href="#模型结构" class="headerlink" title="模型结构"></a>模型结构</h3><p><img src="/img/LeNet/image1.png" alt></p><p>​                                                                 图1 LeNet-5网络结构图</p><p>​    如图4.1所示，LeNet-5一共包含7层（输入层不作为网络结构），分别由2个卷积层、2个下采样层和3个连接层组成，网络的参数配置如表4.1所示，其中下采样层和全连接层的核尺寸分别代表采样范围和连接矩阵的尺寸（如卷积核尺寸中的$“5\times5\times1/1,6”$表示核大小为$5\times5\times1$、步长为$1​$且核个数为6的卷积核）。</p><p>​                                                                 表1 LeNet-5网络参数配置</p><div class="table-container"><table><thead><tr><th style="text-align:center">网络层</th><th style="text-align:center">输入尺寸</th><th style="text-align:center">核尺寸</th><th style="text-align:center">输出尺寸</th><th style="text-align:center">可训练参数量</th></tr></thead><tbody><tr><td style="text-align:center">卷积层$C_1$</td><td style="text-align:center">$32\times32\times1$</td><td style="text-align:center">$5\times5\times1/1,6$</td><td style="text-align:center">$28\times28\times6$</td><td style="text-align:center">$(5\times5\times1+1)\times6$</td></tr><tr><td style="text-align:center">下采样层$S_2$</td><td style="text-align:center">$28\times28\times6$</td><td style="text-align:center">$2\times2/2$</td><td style="text-align:center">$14\times14\times6$</td><td style="text-align:center">$(1+1)\times6$ $^*$</td></tr><tr><td style="text-align:center">卷积层$C_3$</td><td style="text-align:center">$14\times14\times6$</td><td style="text-align:center">$5\times5\times6/1,16$</td><td style="text-align:center">$10\times10\times16$</td><td style="text-align:center">$1516^*$</td></tr><tr><td style="text-align:center">下采样层$S_4$</td><td style="text-align:center">$10\times10\times16$</td><td style="text-align:center">$2\times2/2$</td><td style="text-align:center">$5\times5\times16$</td><td style="text-align:center">$(1+1)\times16$</td></tr><tr><td style="text-align:center">卷积层$C_5$$^*$</td><td style="text-align:center">$5\times5\times16$</td><td style="text-align:center">$5\times5\times16/1,120$</td><td style="text-align:center">$1\times1\times120$</td><td style="text-align:center">$(5\times5\times16+1)\times120$</td></tr><tr><td style="text-align:center">全连接层$F_6$</td><td style="text-align:center">$1\times1\times120$</td><td style="text-align:center">$120\times84$</td><td style="text-align:center">$1\times1\times84$</td><td style="text-align:center">$(120+1)\times84$</td></tr><tr><td style="text-align:center">输出层</td><td style="text-align:center">$1\times1\times84$</td><td style="text-align:center">$84\times10$</td><td style="text-align:center">$1\times1\times10$</td><td style="text-align:center">$(84+1)\times10$</td></tr></tbody></table></div><blockquote><p>​    $^*$ 在LeNet中，下采样操作和池化操作类似，但是在得到采样结果后会乘以一个系数和加上一个偏置项，所以下采样的参数个数是$(1+1)\times6​$而不是零。</p><p>​    $^*$ $C_3$卷积层可训练参数并未直接连接$S_2$中所有的特征图（Feature Map），而是采用如图4.2所示的采样特征方式进行连接（稀疏连接），生成的16个通道特征图中分别按照相邻3个特征图、相邻4个特征图、非相邻4个特征图和全部6个特征图进行映射，得到的参数个数计算公式为$6\times(25\times3+1)+6\times(25\times4+1)+3\times(25\times4+1)+1\times(25\times6+1)=1516$，在原论文中解释了使用这种采样方式原因包含两点：限制了连接数不至于过大（当年的计算能力比较弱）;强制限定不同特征图的组合可以使映射得到的特征图学习到不同的特征模式。</p></blockquote><p><img src="/img/LeNet/featureMap.jpg" alt="FeatureMap"></p><p>​                                                                图2 $S_2$与$C_3$之间的特征图稀疏连接</p><blockquote><p>​    $^*$ $C_5$卷积层在图4.1中显示为全连接层，原论文中解释这里实际采用的是卷积操作，只是刚好在$5\times5$卷积后尺寸被压缩为$1\times1​$，输出结果看起来和全连接很相似。</p></blockquote><h3 id="模型特性"><a href="#模型特性" class="headerlink" title="模型特性"></a>模型特性</h3><ul><li>卷积网络使用一个3层的序列组合：卷积、下采样（池化）、非线性映射（LeNet-5最重要的特性，奠定了目前深层卷积网络的基础）</li><li>使用卷积提取空间特征</li><li>使用映射的空间均值进行下采样</li><li>使用$tanh$或$sigmoid$进行非线性映射</li><li>多层神经网络（MLP）作为最终的分类器</li><li>层间的稀疏连接矩阵以避免巨大的计算开销</li></ul>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 经典网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SCUPC I</title>
      <link href="/2019/04/26/SCUPC-I/"/>
      <url>/2019/04/26/SCUPC-I/</url>
      
        <content type="html"><![CDATA[<h3 id="SOJ-4636-Garden-Aesthetics"><a href="#SOJ-4636-Garden-Aesthetics" class="headerlink" title="SOJ 4636 Garden Aesthetics"></a><a href="http://acm.scu.edu.cn/soj/problem.action?id=4636" target="_blank" rel="noopener">SOJ 4636 Garden Aesthetics</a></h3><h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><p>给定<code>500000</code>个点，在任意4宫格中若有3个点，那么需要增加一个点填满四宫格，求所需要增加的点的个数<br>可以将点的x和y坐标拆分为两部建立二分图，每个存在的点为一条边，每一个联通块中所有未相连的边都是可以增加的点，所以对于每一个联通块来说，所需要增加点的个数等于其x坐标的个数*y坐标的个数-已存在的边数。</p><p>使用 <strong>并查集</strong> 来维护联通块，以及每个联通块中x坐标数和y坐标数以及已存在的边数。<br><br><br>对于任意一个四宫格，如果已存在3个点，那么进行合并操作后联通块一定包含有第4个点的x，y坐标，那么没有边相连的x，y坐标显然就是可以增加的点。比如下图的情况，绿色的边即为可添加的点。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">500000</span>;</span><br><span class="line"><span class="keyword">int</span> father[MAXN*<span class="number">2</span>+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> cntx[MAXN*<span class="number">2</span>+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> cnty[MAXN*<span class="number">2</span>+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> cntedge[MAXN*<span class="number">2</span>+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> tot;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    tot=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=MAXN;i++)&#123;</span><br><span class="line">        cntx[i]=<span class="number">1</span>;</span><br><span class="line">        father[i]=i;</span><br><span class="line">        cntedge[i]=cnty[i]=<span class="number">0</span>;</span><br><span class="line">    &#125;<span class="comment">//存x点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=MAXN+<span class="number">1</span>;i&lt;=MAXN*<span class="number">2</span>+<span class="number">2</span>;i++)&#123;</span><br><span class="line">        cnty[i]=<span class="number">1</span>;</span><br><span class="line">        father[i]=i;</span><br><span class="line">        cntedge[i]=cntx[i]=<span class="number">0</span>;</span><br><span class="line">    &#125;<span class="comment">//存y点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(father[x]!=x)&#123;</span><br><span class="line">        <span class="keyword">return</span> father[x]=find(father[x]);<span class="comment">//路径压缩</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">uunion</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fa=find(a);</span><br><span class="line">    <span class="keyword">int</span> fb=find(b);</span><br><span class="line">    <span class="keyword">if</span>(fa!=fb)&#123;</span><br><span class="line">        father[fa]=fb;</span><br><span class="line">        cntedge[fb]+=cntedge[fa];</span><br><span class="line">        cntx[fb]+=cntx[fa];</span><br><span class="line">        cnty[fb]+=cnty[fa];</span><br><span class="line">        <span class="comment">//一起维护边数和x，y坐标数</span></span><br><span class="line">    &#125;</span><br><span class="line">    cntedge[fb]++;<span class="comment">//每合并一组x，y即存在一条边</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a,b;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n)!=EOF)&#123;</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b);</span><br><span class="line">            uunion(a,b+MAXN+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=MAXN*<span class="number">2</span>+<span class="number">2</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(find(i)==i)</span><br><span class="line">                ans+=((<span class="keyword">long</span> <span class="keyword">long</span>)cntx[i]*(<span class="keyword">long</span> <span class="keyword">long</span>)cnty[i]-cntedge[i]);<span class="comment">//注意long long</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SCUPC B+D</title>
      <link href="/2019/04/23/SCUPC-B-D/"/>
      <url>/2019/04/23/SCUPC-B-D/</url>
      
        <content type="html"><![CDATA[<hr><h3 id="SOJ-4616-CaCO3-Tree"><a href="#SOJ-4616-CaCO3-Tree" class="headerlink" title="SOJ 4616 CaCO3 Tree"></a><a href="http://acm.scu.edu.cn/soj/problem.action?id=4616" target="_blank" rel="noopener">SOJ 4616 CaCO3 Tree</a></h3><h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><p>给定一棵n个结点的树和m条虚线边，求没有虚线连接到自身之外结点的子树个数<br>对于每一对虚线边的结点，结点到其LCA的每个点（除了LCA本身）为根结点的子树一定不符合要求统计未被标记的点的个数即是所求的子树个数<br>使用树上差分，由于LCA本身不标记，所以类似于对于边的差分，将差分数组的LCA结点-2，虚线边结点+1，从根结点dfs维护子树和，即可完成标记<br>ps:貌似卡读入</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">100005</span>;</span><br><span class="line"><span class="keyword">int</span> n,tot,a,b,n1;</span><br><span class="line"><span class="keyword">int</span> head[MAXN*<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> vis[MAXN];</span><br><span class="line"><span class="keyword">int</span> dep[MAXN];</span><br><span class="line"><span class="keyword">int</span> cnt[MAXN];</span><br><span class="line"><span class="comment">//int in[MAXN];</span></span><br><span class="line"><span class="comment">//int out[MAXN];</span></span><br><span class="line"><span class="keyword">int</span> f[MAXN][<span class="number">100</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to,next;</span><br><span class="line">&#125;edge[MAXN*<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> treenode[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="keyword">sizeof</span>(head));</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="built_in">memset</span>(dep,<span class="number">0</span>,<span class="keyword">sizeof</span>(dep));</span><br><span class="line">    <span class="built_in">memset</span>(cnt,<span class="number">0</span>,<span class="keyword">sizeof</span>(cnt));</span><br><span class="line">    tot=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    edge[tot].to=v;</span><br><span class="line">    edge[tot].next=head[u];</span><br><span class="line">    head[u]=tot++;</span><br><span class="line">    edge[tot].to=u;</span><br><span class="line">    edge[tot].next=head[v];</span><br><span class="line">    head[v]=tot++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> rt)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.push(rt);</span><br><span class="line">    f[rt][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    dep[rt]=<span class="number">1</span>;</span><br><span class="line">    vis[rt]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> fa=q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[fa];i!=<span class="number">-1</span>;i=edge[i].next)&#123;</span><br><span class="line">            <span class="keyword">int</span> v=edge[i].to;</span><br><span class="line">            <span class="keyword">if</span>(!vis[v])&#123;</span><br><span class="line">                dep[v]=dep[fa]+<span class="number">1</span>;</span><br><span class="line">                f[v][<span class="number">0</span>]=fa;</span><br><span class="line">                vis[v]=<span class="number">1</span>;</span><br><span class="line">                q.push(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cal_dep</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;(<span class="number">1</span>&lt;&lt;j)&lt;MAXN;j++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;MAXN;i++)&#123;</span><br><span class="line">            f[i][j]=f[f[i][j<span class="number">-1</span>]][j<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dep[u]&lt;dep[v])swap(u,v);</span><br><span class="line">    <span class="keyword">int</span> d=dep[u]-dep[v];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;(<span class="number">1</span>&lt;&lt;i)&lt;=MAXN;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>((<span class="number">1</span>&lt;&lt;i)&amp;d)u=f[u][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(u!=v)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=(<span class="keyword">int</span>)<span class="built_in">log</span>(MAXN);i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(f[u][i]!=f[v][i])&#123;</span><br><span class="line">                u=f[u][i];</span><br><span class="line">                v=f[v][i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[u][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">vis[u]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i!=<span class="number">-1</span>;i=edge[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> v=edge[i].to;</span><br><span class="line">        <span class="keyword">if</span>(!vis[v])&#123;</span><br><span class="line">            dfs(v);</span><br><span class="line">            cnt[u]+=cnt[v];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n)&#123;</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b);</span><br><span class="line">            addedge(a,b);</span><br><span class="line">        &#125;</span><br><span class="line">        bfs(<span class="number">1</span>);</span><br><span class="line">        cal_dep();</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;n1;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n1;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b);</span><br><span class="line">            cnt[a]++;</span><br><span class="line">            cnt[b]++;</span><br><span class="line">            <span class="keyword">int</span> k=lca(a,b);</span><br><span class="line">            cnt[k]-=<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">        dfs(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!cnt[i])&#123;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="SOJ-4631-CRY-cry"><a href="#SOJ-4631-CRY-cry" class="headerlink" title="SOJ 4631 CRY cry"></a><a href="http://acm.scu.edu.cn/soj/problem.action?id=4631" target="_blank" rel="noopener">SOJ 4631 CRY cry</a></h3><h4 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h4><p>对于给出的每一个1操作，将给的点分成同一种类的三个值，操作0对结果无影响，将所有点按照值的大小排序，使用双指针（不符合要求右指针右移，符合要求左指针右移到不符合要求为止）跑完整个序列，维护最小值,判断条件保持线性</p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">100005</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">  <span class="keyword">int</span> index;</span><br><span class="line">  <span class="keyword">int</span> val;</span><br><span class="line">&#125;node[MAXN*<span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Node a,Node b)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a.val&lt;b.val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> vis[MAXN*<span class="number">3</span>];</span><br><span class="line"><span class="keyword">int</span> n,a,b,c,d;</span><br><span class="line"><span class="keyword">int</span> tot,tott,zero_cnt,que;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n)&#123;</span><br><span class="line">    tot=<span class="number">0</span>;</span><br><span class="line">    tott=<span class="number">0</span>;</span><br><span class="line">    zero_cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">      <span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b;</span><br><span class="line">      <span class="keyword">if</span>(b==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;c&gt;&gt;d;</span><br><span class="line">        node[tot].index=tott;</span><br><span class="line">        node[tot++].val=a;</span><br><span class="line">        node[tot].index=tott;</span><br><span class="line">        node[tot++].val=a+c;</span><br><span class="line">        node[tot].index=tott++;</span><br><span class="line">        node[tot++].val=a-d;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span>&#123;</span><br><span class="line">        zero_cnt++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(node,node+tot,cmp);</span><br><span class="line">    <span class="comment">//cout&lt;&lt;node[0].val&lt;&lt;endl;</span></span><br><span class="line">    <span class="keyword">if</span>(zero_cnt==n)<span class="built_in">cout</span>&lt;&lt;<span class="number">0</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">int</span> flag=<span class="number">0</span>;</span><br><span class="line">    que=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;tott;k++)&#123;</span><br><span class="line">  vis[node[k].index]++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;tott;k++)&#123;</span><br><span class="line">  <span class="keyword">if</span>(!vis[k])&#123;</span><br><span class="line">  flag=<span class="number">1</span>;</span><br><span class="line">  que++;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(flag==<span class="number">0</span>)&#123;</span><br><span class="line">  ans=node[tott<span class="number">-1</span>].val-node[<span class="number">0</span>].val;</span><br><span class="line">  &#125;</span><br><span class="line">  j=tott<span class="number">-1</span>;</span><br><span class="line">  i=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(j&lt;tot)&#123;</span><br><span class="line">  <span class="keyword">while</span>(flag==<span class="number">1</span>&amp;&amp;j&lt;tot)&#123;</span><br><span class="line">  j++;</span><br><span class="line">  vis[node[j].index]++;</span><br><span class="line">  <span class="keyword">if</span>(vis[node[j].index]==<span class="number">1</span>)que--;</span><br><span class="line">  <span class="keyword">if</span>(que==<span class="number">0</span>)&#123;</span><br><span class="line">  flag=<span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(flag==<span class="number">0</span>&amp;&amp;j&lt;tot)&#123;</span><br><span class="line">  i++;</span><br><span class="line">  vis[node[i<span class="number">-1</span>].index]--;</span><br><span class="line">  <span class="keyword">if</span>(vis[node[i<span class="number">-1</span>].index]==<span class="number">0</span>)que++;</span><br><span class="line">  <span class="keyword">if</span>(que&gt;<span class="number">0</span>)&#123;</span><br><span class="line">  flag=<span class="number">1</span>;</span><br><span class="line">  ans=min(ans,node[j].val-node[i<span class="number">-1</span>].val);</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>支持向量机</title>
      <link href="/2019/04/19/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/"/>
      <url>/2019/04/19/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<h3 id="SVM简介"><a href="#SVM简介" class="headerlink" title="SVM简介"></a>SVM简介</h3><p>支持向量机(Support Vector Machine)是Cortes和Vapnik于1995年首先提出的，它在解决小样本、非线性及高维模式识别中表现出许多特有的优势，并能够推广应用到函数拟合等其他机器学习问题中。<br>支持向量机方法是建立在统计学习理论的VC 维理论和结构风险最小原理基础上的，根据有限的样本信息在模型的复杂性（即对特定训练样本的学习精度，Accuracy）和学习能力（即无错误地识别任意样本的能力）之间寻求最佳折衷，以期获得最好的推广能力。<br><br></p><h3 id="线性分类"><a href="#线性分类" class="headerlink" title="线性分类"></a>线性分类</h3><p>给定训练样本集 $ D=((x_1,y_1),(x_2,y_2),…,(x_m,y_m)),y_i\in\{-1,1\} $，线性分类器基于训练样本集D找到一个超平面 $ f(x)=W^Tx+b$ 区分两类数据。<br>当$ f(x)&gt;0 $时表示$ y=1 $的点，$ f(x)<0 $时表示$ y="-1" $的点，当$ f(x)="0" $时，表示该点在超平面上。当超平面距离两边的数据间距越大，则表示该超平面抗干扰性越好 <br></0></p><h3 id="支持向量"><a href="#支持向量" class="headerlink" title="支持向量"></a>支持向量</h3><p><br></p><script type="math/tex; mode=display">{w^Tx_i+b\geq1,y_i=1\atop w^Tx_i+b\leq-1,y_i=-1}</script><p><em>支持向量</em> 就是使得上式等号成立的，最靠近两条虚边界线的向量。<br>我们可以通过计算得到每一样本点$x$到超平面的距离为 $ r=\frac{|w^Tx+b|}{||w||} $<br>支持向量满足上述等式，由$w^Tx_0+b=0$($x_0$为垂点)可得 $ r=\frac{|w^Tx+b|}{||w||} $<br>推出 $ r=\frac{2}{||w||} $<br>得SVM的基本型</p><script type="math/tex; mode=display">max\frac{2}{||w||}\atop{s.t.y_i(w^Tx_i+b)\geq1,i=1,2,...,m}</script><p>等价于</p><script type="math/tex; mode=display">min\frac{1}{2}||w||^2\atop{s.t.y_i(w^Tx_i+b\geq,i=1,2,...m)}</script><p>使用拉格朗日乘数法求解</p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CodeForces 933A A Twisty Movement 题解</title>
      <link href="/2019/04/17/CodeForces_933A/"/>
      <url>/2019/04/17/CodeForces_933A/</url>
      
        <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>有一个由1和2构成的序列，你可以选择一个区间<a href="1≤ l ≤ r ≤ n">l,r</a>翻转，即这段区间就变成ar,ar-1,…,al+1,al。使得新序列中的non-decreasing subsequence最长。<br>一个长为k的non-decreasing subsequence是，一个满足下标p1 &lt; p2 &lt; … &lt; pk并且，ap1 ≤ ap2 ≤ … ≤ apk的子序列。</p><h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>第一行一个整数n (1 ≤ n ≤ 2000)，表示原串的长度。<br>第二行包含n个整数，表示a1, a2, …, an (1 ≤ ai ≤ 2, i = 1, 2, …, n)。</p><h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>Print a single integer, which means the maximum possible length of the longest non-decreasing subsequence of the new sequence.</p><h2 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h2><p>Input<br><code>4</code><br><code>1 2 1 2</code><br>Output<br><code>4</code><br>Input<br><code>10</code><br><code>1 1 2 2 2 1 1 2 2 1</code><br>Output<br><code>9</code></p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_N=<span class="number">2005</span>;</span><br><span class="line"><span class="keyword">int</span> n,ans;</span><br><span class="line"><span class="keyword">int</span> pre[MAX_N],nex[MAX_N],dp[MAX_N],a[MAX_N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">dp[i]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;i;++j)</span><br><span class="line"><span class="keyword">if</span>(a[j]&lt;=a[i]&amp;&amp;dp[j]+<span class="number">1</span>&gt;dp[i])</span><br><span class="line">                dp[i]=dp[j]+<span class="number">1</span>;</span><br><span class="line">pre[i]=max(dp[i],pre[i<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">dp[i]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=n;j&gt;i;j--)</span><br><span class="line"><span class="keyword">if</span>(a[j]&gt;=a[i]&amp;&amp;dp[j]+<span class="number">1</span>&gt;dp[i])</span><br><span class="line">                dp[i]=dp[j]+<span class="number">1</span>;</span><br><span class="line">nex[i]=max(dp[i],nex[i+<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        ans=max(ans,pre[i]+nex[i+<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>由于问题给出的数列只有1，2两个元素，所以我们所求的区间翻转后的LIS必然为若干个1接上若干个2.所以考虑该LIS在区间翻转前的状态一定为若干个1接上若干个2再接上若干个1和若干个2.所以要求翻转后的LIS的长度，就可以将整个序列分为两部分，前半部分求其正向非减的最大长度，后半部分求其逆向非增的最大长度，将其求和即可得到翻转后的LIS长度，最后求最大值即可。</p><h2 id="题目地址"><a href="#题目地址" class="headerlink" title="题目地址"></a>题目地址</h2><p><a href="http://codeforces.com/problemset/problem/933/A" target="_blank" rel="noopener">CodeForces 933A A Twisty Movement</a></p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
