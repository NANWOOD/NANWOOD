<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>AlexNet</title>
      <link href="/2020/02/09/AlexNet/"/>
      <url>/2020/02/09/AlexNet/</url>
      
        <content type="html"><![CDATA[<h3 id="模型介绍"><a href="#模型介绍" class="headerlink" title="模型介绍"></a>模型介绍</h3><p>​    AlexNet是由$Alex$ $Krizhevsky $提出的首个应用于图像分类的深层卷积神经网络，该网络在2012年ILSVRC（ImageNet Large Scale Visual Recognition Competition）图像分类竞赛中以15.3%的top-5测试错误率赢得第一名$^{[2]}$。AlexNet使用GPU代替CPU进行运算，使得在可接受的时间范围内模型结构能够更加复杂，它的出现证明了深层卷积神经网络在复杂模型下的有效性，使CNN在计算机视觉中流行开来，直接或间接地引发了深度学习的热潮。</p><h3 id="模型结构"><a href="#模型结构" class="headerlink" title="模型结构"></a>模型结构</h3><p><img src="/img/LeNet/alexnet.png" alt></p><p>​                                                                         图3 AlexNet网络结构图</p><p>​    如图4.3所示，除去下采样（池化层）和局部响应规范化操作（Local Responsible Normalization, LRN），AlexNet一共包含8层，前5层由卷积层组成，而剩下的3层为全连接层。网络结构分为上下两层，分别对应两个GPU的操作过程，除了中间某些层（$C_3$卷积层和$F_{6-8}$全连接层会有GPU间的交互），其他层两个GPU分别计算结 果。最后一层全连接层的输出作为$softmax$的输入，得到1000个图像分类标签对应的概率值。除去GPU并行结构的设计，AlexNet网络结构与LeNet十分相似，其网络的参数配置如表4.2所示。</p><p>​                                    表2 AlexNet网络参数配置</p><div class="table-container"><table><thead><tr><th style="text-align:center">网络层</th><th style="text-align:center">输入尺寸</th><th style="text-align:center">核尺寸</th><th style="text-align:center">输出尺寸</th><th style="text-align:center">可训练参数量</th></tr></thead><tbody><tr><td style="text-align:center">卷积层$C_1$ $^*$</td><td style="text-align:center">$224\times224\times3$</td><td style="text-align:center">$11\times11\times3/4,48(\times2_{GPU})$</td><td style="text-align:center">$55\times55\times48(\times2_{GPU})$</td><td style="text-align:center">$(11\times11\times3+1)\times48\times2$</td></tr><tr><td style="text-align:center">下采样层$S_{max}$$^*$</td><td style="text-align:center">$55\times55\times48(\times2_{GPU})$</td><td style="text-align:center">$3\times3/2(\times2_{GPU})$</td><td style="text-align:center">$27\times27\times48(\times2_{GPU})$</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">卷积层$C_2$</td><td style="text-align:center">$27\times27\times48(\times2_{GPU})$</td><td style="text-align:center">$5\times5\times48/1,128(\times2_{GPU})$</td><td style="text-align:center">$27\times27\times128(\times2_{GPU})$</td><td style="text-align:center">$(5\times5\times48+1)\times128\times2$</td></tr><tr><td style="text-align:center">下采样层$S_{max}$</td><td style="text-align:center">$27\times27\times128(\times2_{GPU})$</td><td style="text-align:center">$3\times3/2(\times2_{GPU})$</td><td style="text-align:center">$13\times13\times128(\times2_{GPU})$</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">卷积层$C_3$ $^*$</td><td style="text-align:center">$13\times13\times128\times2_{GPU}$</td><td style="text-align:center">$3\times3\times256/1,192(\times2_{GPU})$</td><td style="text-align:center">$13\times13\times192(\times2_{GPU})$</td><td style="text-align:center">$(3\times3\times256+1)\times192\times2$</td></tr><tr><td style="text-align:center">卷积层$C_4$</td><td style="text-align:center">$13\times13\times192(\times2_{GPU})$</td><td style="text-align:center">$3\times3\times192/1,192(\times2_{GPU})$</td><td style="text-align:center">$13\times13\times192(\times2_{GPU})$</td><td style="text-align:center">$(3\times3\times192+1)\times192\times2$</td></tr><tr><td style="text-align:center">卷积层$C_5$</td><td style="text-align:center">$13\times13\times192(\times2_{GPU})$</td><td style="text-align:center">$3\times3\times192/1,128(\times2_{GPU})$</td><td style="text-align:center">$13\times13\times128(\times2_{GPU})$</td><td style="text-align:center">$(3\times3\times192+1)\times128\times2$</td></tr><tr><td style="text-align:center">下采样层$S_{max}$</td><td style="text-align:center">$13\times13\times128(\times2_{GPU})$</td><td style="text-align:center">$3\times3/2(\times2_{GPU})$</td><td style="text-align:center">$6\times6\times128(\times2_{GPU})$</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">全连接层$F_6$  $^*$</td><td style="text-align:center">$6\times6\times128\times2_{GPU}$</td><td style="text-align:center">$9216\times2048(\times2_{GPU})$</td><td style="text-align:center">$1\times1\times2048(\times2_{GPU})$</td><td style="text-align:center">$(9216+1)\times2048\times2$</td></tr><tr><td style="text-align:center">全连接层$F_7$</td><td style="text-align:center">$1\times1\times2048\times2_{GPU}$</td><td style="text-align:center">$4096\times2048(\times2_{GPU})$</td><td style="text-align:center">$1\times1\times2048(\times2_{GPU})$</td><td style="text-align:center">$(4096+1)\times2048\times2$</td></tr><tr><td style="text-align:center">全连接层$F_8$</td><td style="text-align:center">$1\times1\times2048\times2_{GPU}$</td><td style="text-align:center">$4096\times1000$</td><td style="text-align:center">$1\times1\times1000$</td><td style="text-align:center">$(4096+1)\times1000\times2$</td></tr></tbody></table></div><blockquote><p>卷积层$C_1$输入为$224\times224\times3$的图片数据，分别在两个GPU中经过核为$11\times11\times3$、步长（stride）为4的卷积卷积后，分别得到两条独立的$55\times55\times48$的输出数据。</p><p>下采样层$S_{max}$实际上是嵌套在卷积中的最大池化操作，但是为了区分没有采用最大池化的卷积层单独列出来。在$C_{1-2}$卷积层中的池化操作之后（ReLU激活操作之前），还有一个LRN操作，用作对相邻特征点的归一化处理。</p><p>卷积层$C_3$ 的输入与其他卷积层不同，$13\times13\times192\times2_{GPU}$表示汇聚了上一层网络在两个GPU上的输出结果作为输入，所以在进行卷积操作时通道上的卷积核维度为384。</p><p>全连接层$F_{6-8}$中输入数据尺寸也和$C_3$类似，都是融合了两个GPU流向的输出结果作为输入。</p></blockquote><h3 id="模型特性"><a href="#模型特性" class="headerlink" title="模型特性"></a>模型特性</h3><ul><li>所有卷积层都使用ReLU作为非线性映射函数，使模型收敛速度更快</li><li>在多个GPU上进行模型的训练，不但可以提高模型的训练速度，还能提升数据的使用规模</li><li>使用LRN对局部的特征进行归一化，结果作为ReLU激活函数的输入能有效降低错误率</li><li>重叠最大池化（overlapping max pooling），即池化范围z与步长s存在关系$z&gt;s$（如$S_{max}$中核尺度为$3\times3/2$），避免平均池化（average pooling）的平均效应</li><li>使用随机丢弃技术（dropout）选择性地忽略训练中的单个神经元，避免模型的过拟合</li></ul>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 经典网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>极限</title>
      <link href="/2020/02/08/%E6%9E%81%E9%99%90/"/>
      <url>/2020/02/08/%E6%9E%81%E9%99%90/</url>
      
        <content type="html"><![CDATA[<h3 id="伯努利不等式（Bernoulli）"><a href="#伯努利不等式（Bernoulli）" class="headerlink" title="伯努利不等式（Bernoulli）"></a>伯努利不等式（Bernoulli）</h3><p>设实数$x\ge-1$，则对任意正整数n成立不等式</p><script type="math/tex; mode=display">(1+x)^n\ge1+nx</script><p>等号成立的充分必要条件是$x=0$或者$x=-1,n=1$<br><strong>证明</strong> 在$x\ge0$时，左边按二项式定力展开可以看到它是成立的，所以关键是如何证明x<0的情况 <br>在等式 $a^n-b^n = (a-b)(a^{n-1}+a^{n-2}b+\cdots+ab^{n-2}+b^{n-1})$<br>在式中令$a=1+x$，$b=1$便得$(1+x)^n-1=x \left[ (1+x)^{n-1}+(1+x)^{n-2}+\cdots+(1+x)+1 \right]$<br>如果$x&gt;0$，则右边中括号内的部分显然大于$n$，于是要证的不等式成立，而如果$-1&lt; x &lt; 0$，则中括号内的部分小于$n$，再与负数$x$相乘，不等式反向即证出伯努利不等式。</0的情况></p><h3 id="数列极限"><a href="#数列极限" class="headerlink" title="数列极限"></a>数列极限</h3><p>对于实数数列${a_n}$和实数$a$，如果对于任意小的正实数$\varepsilon$，都存在某一下标$N$，使得该数列在这之后的所有项(即$n&gt;N$)都满足$|a_n-a|&lt;\varepsilon$则称该数列存在极限，实数$a$称为该数列的极限。也称该数列为收敛数列，并且收敛到实数$a$，记为 <script type="math/tex">\lim_{n \to \infty}x_n = a</script><br><strong>极限唯一性</strong>：<em>如果数列$x_n$收敛，则极限唯一。</em><br><strong>保号性</strong>：<em>如果数列收敛到一个正的实数，则数列必从某向起恒保持正号，同样，若收敛到一个负的实数，则必从某项起保持负号。</em><br><strong>收敛数列的有界性</strong>：<em>收敛数列必有界。</em><br><strong>保不等性</strong>：<em>设数列$a_n$与数列$b_n$分别收敛到$A$与$B$，且当$n$充分大时恒有$a_n &lt; b_n$，则必有$A \le B$</em><br><strong>夹逼准则</strong>：<em>若三个数列$a_n、b_n、c_n$在$n$充分大时恒有$a_n \le b_n \le c_n$，并且$a_n$与$c_n$都收敛到同一极限$M$，则$b_n$亦必收敛到此极限值</em></p><h3 id="数列柯西收敛准则"><a href="#数列柯西收敛准则" class="headerlink" title="数列柯西收敛准则"></a>数列柯西收敛准则</h3><p>数列$x_n$收敛的充分必要条件是，对于任意正实数$\varepsilon$，总存在正整数$N &gt; 0$，使得任意$n_1 &gt; N$和任意$n_2 &gt; N$恒有$|x_{n1} - x_{n2} &lt; \varepsilon|$。</p><h3 id="数列的极限"><a href="#数列的极限" class="headerlink" title="数列的极限"></a>数列的极限</h3><p><strong>数列的上极限和下极限</strong>：数列$a_n$的最大聚点（可以为无穷）称为数列的上极限，记作$\overline{\lim}\limits_{n \to \infty}a_n$，而最小的聚点称为它的下极限，记作$\underline{\lim}\limits_{n \to \infty}a_n$。<br><strong>数列极限存在</strong>：数列存在极限的充分必要条件是，它的上极限与下极限相等。<br><em>聚点：对于无穷数集$A$和某个实数$x$，若$x$的任意小的领域$(x - \varepsilon, x_\varepsilon)$内都包含了$A$中的无穷多个数，则称数$x$是数集$A$的一个聚点</em><br><em>数$A$是数列$\begin{Bmatrix} a_n \end{Bmatrix}$的一个聚点的充分必要条件是，这个数列存在收敛到$A$的子数列。</em></p><h3 id="函数的极限"><a href="#函数的极限" class="headerlink" title="函数的极限"></a>函数的极限</h3><p><strong>定义</strong>：设函数$f(x)$在无穷区间$(a, +\infty)$上有定义，$A$是一个实数，如果对于任意小的正实数$\varepsilon$，总存在实数$X(&gt;a)$，使得$x &gt; X$时恒有$|f(x) - A| &lt; \varepsilon$成立，则称数$A$是函数$f(x)$在自变量趋于正无穷大时的<strong>极限</strong>，记作$\lim\limits_{x \to \infty}f(x) = A$。<br><strong>趋点极限</strong>：设函数$f(x)$在$x_0$的某空心邻域内有定义，$A$是一个实数，如果对于任意小的正实数$\varepsilon &gt; 0$，总存在另一正实数$\delta &gt; 0$，使得定义域中满足$0 &lt; |x - x_0| &lt; \delta$的数恒有$|f(x) - A &lt; \varepsilon|$，则称$A$是函数$f(x)$当自变量趋于$x_0$时的极限，记作$\lim\limits_{x \to x_o}f(x) = A$。<br><strong>单侧极限</strong>：如果函数$f(x)$在$x_0$的某个右空心邻域内有定义，$A$是一个实数，如果对于任意小的正实数$\varepsilon &gt; 0$，都存在另一个正实数$\delta &gt; 0$，使得当$x_0 &lt; x &lt; x_0 + \delta$时恒有$|f(x) - A| &lt; \delta$成立，则称$A$是函数$f(x)$在$x_0$处的<strong>右极限</strong>，记作$\lim\limits_{x \to x_0^+}f(x) = A$。把右空心邻域改为左空心邻域，把不等式$x_0 &lt; x &lt; x_0 + \delta$换成$x_0 - \delta &lt; x &lt; x_0$，就可以得到<strong>左极限</strong>的定义，记作：$\lim\limits_{x \to x_0^-}f(x) = A$。<em>显然，$\lim\limits_{x \to x_0}f(x) = A$的充分必要条件是$\lim\limits_{x \to x_0^+}f(x) = \lim\limits_{x \to x_0^-}f(x) = A$。</em></p><h3 id="函数极限的性质"><a href="#函数极限的性质" class="headerlink" title="函数极限的性质"></a>函数极限的性质</h3><p><strong>唯一性</strong>：函数极限$\lim\limits_{c \to x_0}f(x)$若存在必唯一。<br><strong>局部有界性</strong>：设函数$f(x)$在$x_0$的某空心邻域内有定义，若$\lim\limits_{x \to x_0}f(x)$存在（非无穷的有限值），则$f(x)$在$x_0$的某个空心邻域内有界。<br><strong>局部保号性</strong>：若函数$f(x)$在$x \to x_0$处的极限存在为$A$，则对于任意$r &lt; A$都存在$x_0$的某个空心邻域内，在这邻域内恒有$f(x) &gt; r$，同样，对于任意$r &gt; A$，都存在$x_0$的某空心邻域，在这邻域内恒有$f(x) &lt; r$。<br><strong>保不等式性</strong>：如果函数$f(x)$和$g(z)$都在$x_0$的某个空心邻域内有定义，且在这邻域内上恒满足$f(x) \ge g(x)$，那么如果当$x \to x_0$时两个函数分别有极限$A$和$B$，则必有$A \ge B$。<br><strong>夹逼定理</strong>：在$x_0$的某空心邻域内有定义的三个函数$f(x)、g(x)、h(x)$，如果在该邻域内恒满足$f(x) \le h(x) \le g(x)$，那么如果当时$f(x)$和$g(x)$都收敛到$A$，那么这时$h(x)$也必收敛且到收敛到$A$。<br><strong>四则运算法则</strong>：如果在$x_0$的某空心邻域内有定义的两个函数$f(x)、g(x)$在时分别收敛到$A、B$，那么由这两个函数的和、差、积、商作成的新函数也收敛，并收敛到原先两个极限值的和、差、积、商，商的情况需要满足分母不为0.<br><strong>复合函数的极限</strong>：设有如下函数极限$\lim\limits_{x \to x_0}g(x) = u_0, \lim\limits_{u \to u_0}f(u) = y_0$，且$g(x)$在$x_0$的某空心邻域上恒有$g(x) \ne u_0$，则有$\lim\limits_{x \to x_0}f(g(x)) = y_0$。<br><strong>单调有界定理</strong>：如果函数$f(x)$在$x_0$的某左空心邻域内单调递增且有上界，则函数$f(x)$在$x_0$处的左极限存在，右极限也有类似的推论。</p><h3 id="函数柯西收敛准则"><a href="#函数柯西收敛准则" class="headerlink" title="函数柯西收敛准则"></a>函数柯西收敛准则</h3><p>函数$f(x)$在$x_0$的某空心邻域内有定义，则它在该存在极限的充分必要条件是：任给正实数$\varepsilon$，恒存在另一正实数$\delta$，使得对任意满足$|x - x_0| &lt; \delta$的两个实数$x_1$和$x_2$都成立$|f(x_1) - f(x_2) &lt; \varepsilon|$。</p><h3 id="函数的连续性"><a href="#函数的连续性" class="headerlink" title="函数的连续性"></a>函数的连续性</h3><p><strong>连续与单侧连续</strong>：如果函数$f(x)$在$x_0$处存在极限，且极限值正好是该点处的函数值$f(x_0)$，则称函数在$x_0$处连续，即$\lim\limits_{x \to x_0}f(x) = f(x_0)$。如果该点处的左极限等于该点处的函数值，则称函数在该点处<strong>左连续</strong>，<strong>右连续</strong>同理。<br><strong>连续函数</strong>：如果函数在某个区间上处处连续，则称函数在这区间上连续，或者说它是这区间上的<strong>连续函数</strong></p><h3 id="间断点"><a href="#间断点" class="headerlink" title="间断点"></a>间断点</h3><p><strong>定义</strong>：如果函数在某点处不连续，则称该点是函数的一个<strong>间断点</strong>。<br><strong>可去间断点</strong>：函数在某点处不连续但存在极限，极限与函数值不相等或函数值未定义。<br><strong>跳跃间断点</strong>：存在左极限和右极限但两者不相等。<br><strong>第一类间断点</strong>：<strong>可去间断点</strong>和<strong>跳跃间断点</strong>。<br><strong>第二类间断点</strong>：至少有一个单侧极限不存在</p><h3 id="连续函数的性质"><a href="#连续函数的性质" class="headerlink" title="连续函数的性质"></a>连续函数的性质</h3><p><strong>局部有界性</strong>、<strong>局部保号性</strong>、<strong>四则运算法则</strong>同上。<br><strong>复合函数的连续性</strong>：设函数$g(x)$在$x_0$处连续，记$u_0 = g(x_0)$，若另一函数$f(u)$在$u_0$处连续，则复合函数$f(g(x))$在$x_0$处连续。</p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>LeNet-5</title>
      <link href="/2020/02/08/LeNet-5/"/>
      <url>/2020/02/08/LeNet-5/</url>
      
        <content type="html"><![CDATA[<h3 id="模型介绍"><a href="#模型介绍" class="headerlink" title="模型介绍"></a>模型介绍</h3><p>​    LeNet-5是由$LeCun$ 提出的一种用于识别手写数字和机器印刷字符的卷积神经网络（Convolutional Neural Network，CNN）$^{[1]}$，其命名来源于作者$LeCun$的名字，5则是其研究成果的代号，在LeNet-5之前还有LeNet-4和LeNet-1鲜为人知。LeNet-5阐述了图像中像素特征之间的相关性能够由参数共享的卷积操作所提取，同时使用卷积、下采样（池化）和非线性映射这样的组合结构，是当前流行的大多数深度图像识别网络的基础。</p><h3 id="模型结构"><a href="#模型结构" class="headerlink" title="模型结构"></a>模型结构</h3><p><img src="/img/LeNet/image1.png" alt></p><p>​                                                                 图1 LeNet-5网络结构图</p><p>​    如图4.1所示，LeNet-5一共包含7层（输入层不作为网络结构），分别由2个卷积层、2个下采样层和3个连接层组成，网络的参数配置如表4.1所示，其中下采样层和全连接层的核尺寸分别代表采样范围和连接矩阵的尺寸（如卷积核尺寸中的$“5\times5\times1/1,6”$表示核大小为$5\times5\times1$、步长为$1​$且核个数为6的卷积核）。</p><p>​                                                                 表1 LeNet-5网络参数配置</p><div class="table-container"><table><thead><tr><th style="text-align:center">网络层</th><th style="text-align:center">输入尺寸</th><th style="text-align:center">核尺寸</th><th style="text-align:center">输出尺寸</th><th style="text-align:center">可训练参数量</th></tr></thead><tbody><tr><td style="text-align:center">卷积层$C_1$</td><td style="text-align:center">$32\times32\times1$</td><td style="text-align:center">$5\times5\times1/1,6$</td><td style="text-align:center">$28\times28\times6$</td><td style="text-align:center">$(5\times5\times1+1)\times6$</td></tr><tr><td style="text-align:center">下采样层$S_2$</td><td style="text-align:center">$28\times28\times6$</td><td style="text-align:center">$2\times2/2$</td><td style="text-align:center">$14\times14\times6$</td><td style="text-align:center">$(1+1)\times6$ $^*$</td></tr><tr><td style="text-align:center">卷积层$C_3$</td><td style="text-align:center">$14\times14\times6$</td><td style="text-align:center">$5\times5\times6/1,16$</td><td style="text-align:center">$10\times10\times16$</td><td style="text-align:center">$1516^*$</td></tr><tr><td style="text-align:center">下采样层$S_4$</td><td style="text-align:center">$10\times10\times16$</td><td style="text-align:center">$2\times2/2$</td><td style="text-align:center">$5\times5\times16$</td><td style="text-align:center">$(1+1)\times16$</td></tr><tr><td style="text-align:center">卷积层$C_5$$^*$</td><td style="text-align:center">$5\times5\times16$</td><td style="text-align:center">$5\times5\times16/1,120$</td><td style="text-align:center">$1\times1\times120$</td><td style="text-align:center">$(5\times5\times16+1)\times120$</td></tr><tr><td style="text-align:center">全连接层$F_6$</td><td style="text-align:center">$1\times1\times120$</td><td style="text-align:center">$120\times84$</td><td style="text-align:center">$1\times1\times84$</td><td style="text-align:center">$(120+1)\times84$</td></tr><tr><td style="text-align:center">输出层</td><td style="text-align:center">$1\times1\times84$</td><td style="text-align:center">$84\times10$</td><td style="text-align:center">$1\times1\times10$</td><td style="text-align:center">$(84+1)\times10$</td></tr></tbody></table></div><blockquote><p>​    $^*$ 在LeNet中，下采样操作和池化操作类似，但是在得到采样结果后会乘以一个系数和加上一个偏置项，所以下采样的参数个数是$(1+1)\times6​$而不是零。</p><p>​    $^*$ $C_3$卷积层可训练参数并未直接连接$S_2$中所有的特征图（Feature Map），而是采用如图4.2所示的采样特征方式进行连接（稀疏连接），生成的16个通道特征图中分别按照相邻3个特征图、相邻4个特征图、非相邻4个特征图和全部6个特征图进行映射，得到的参数个数计算公式为$6\times(25\times3+1)+6\times(25\times4+1)+3\times(25\times4+1)+1\times(25\times6+1)=1516$，在原论文中解释了使用这种采样方式原因包含两点：限制了连接数不至于过大（当年的计算能力比较弱）;强制限定不同特征图的组合可以使映射得到的特征图学习到不同的特征模式。</p></blockquote><p><img src="/img/LeNet/featureMap.jpg" alt="FeatureMap"></p><p>​                                                                图2 $S_2$与$C_3$之间的特征图稀疏连接</p><blockquote><p>​    $^*$ $C_5$卷积层在图4.1中显示为全连接层，原论文中解释这里实际采用的是卷积操作，只是刚好在$5\times5$卷积后尺寸被压缩为$1\times1​$，输出结果看起来和全连接很相似。</p></blockquote><h3 id="模型特性"><a href="#模型特性" class="headerlink" title="模型特性"></a>模型特性</h3><ul><li>卷积网络使用一个3层的序列组合：卷积、下采样（池化）、非线性映射（LeNet-5最重要的特性，奠定了目前深层卷积网络的基础）</li><li>使用卷积提取空间特征</li><li>使用映射的空间均值进行下采样</li><li>使用$tanh$或$sigmoid$进行非线性映射</li><li>多层神经网络（MLP）作为最终的分类器</li><li>层间的稀疏连接矩阵以避免巨大的计算开销</li></ul>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 经典网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SCUPC I</title>
      <link href="/2019/04/26/SCUPC-I/"/>
      <url>/2019/04/26/SCUPC-I/</url>
      
        <content type="html"><![CDATA[<h3 id="SOJ-4636-Garden-Aesthetics"><a href="#SOJ-4636-Garden-Aesthetics" class="headerlink" title="SOJ 4636 Garden Aesthetics"></a><a href="http://acm.scu.edu.cn/soj/problem.action?id=4636" target="_blank" rel="noopener">SOJ 4636 Garden Aesthetics</a></h3><h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><p>给定<code>500000</code>个点，在任意4宫格中若有3个点，那么需要增加一个点填满四宫格，求所需要增加的点的个数<br>可以将点的x和y坐标拆分为两部建立二分图，每个存在的点为一条边，每一个联通块中所有未相连的边都是可以增加的点，所以对于每一个联通块来说，所需要增加点的个数等于其x坐标的个数*y坐标的个数-已存在的边数。</p><p>使用 <strong>并查集</strong> 来维护联通块，以及每个联通块中x坐标数和y坐标数以及已存在的边数。<br><br><br>对于任意一个四宫格，如果已存在3个点，那么进行合并操作后联通块一定包含有第4个点的x，y坐标，那么没有边相连的x，y坐标显然就是可以增加的点。比如下图的情况，绿色的边即为可添加的点。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">500000</span>;</span><br><span class="line"><span class="keyword">int</span> father[MAXN*<span class="number">2</span>+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> cntx[MAXN*<span class="number">2</span>+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> cnty[MAXN*<span class="number">2</span>+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> cntedge[MAXN*<span class="number">2</span>+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> tot;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    tot=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=MAXN;i++)&#123;</span><br><span class="line">        cntx[i]=<span class="number">1</span>;</span><br><span class="line">        father[i]=i;</span><br><span class="line">        cntedge[i]=cnty[i]=<span class="number">0</span>;</span><br><span class="line">    &#125;<span class="comment">//存x点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=MAXN+<span class="number">1</span>;i&lt;=MAXN*<span class="number">2</span>+<span class="number">2</span>;i++)&#123;</span><br><span class="line">        cnty[i]=<span class="number">1</span>;</span><br><span class="line">        father[i]=i;</span><br><span class="line">        cntedge[i]=cntx[i]=<span class="number">0</span>;</span><br><span class="line">    &#125;<span class="comment">//存y点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(father[x]!=x)&#123;</span><br><span class="line">        <span class="keyword">return</span> father[x]=find(father[x]);<span class="comment">//路径压缩</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">uunion</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fa=find(a);</span><br><span class="line">    <span class="keyword">int</span> fb=find(b);</span><br><span class="line">    <span class="keyword">if</span>(fa!=fb)&#123;</span><br><span class="line">        father[fa]=fb;</span><br><span class="line">        cntedge[fb]+=cntedge[fa];</span><br><span class="line">        cntx[fb]+=cntx[fa];</span><br><span class="line">        cnty[fb]+=cnty[fa];</span><br><span class="line">        <span class="comment">//一起维护边数和x，y坐标数</span></span><br><span class="line">    &#125;</span><br><span class="line">    cntedge[fb]++;<span class="comment">//每合并一组x，y即存在一条边</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a,b;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n)!=EOF)&#123;</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b);</span><br><span class="line">            uunion(a,b+MAXN+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=MAXN*<span class="number">2</span>+<span class="number">2</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(find(i)==i)</span><br><span class="line">                ans+=((<span class="keyword">long</span> <span class="keyword">long</span>)cntx[i]*(<span class="keyword">long</span> <span class="keyword">long</span>)cnty[i]-cntedge[i]);<span class="comment">//注意long long</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SCUPC B+D</title>
      <link href="/2019/04/23/SCUPC-B-D/"/>
      <url>/2019/04/23/SCUPC-B-D/</url>
      
        <content type="html"><![CDATA[<hr><h3 id="SOJ-4616-CaCO3-Tree"><a href="#SOJ-4616-CaCO3-Tree" class="headerlink" title="SOJ 4616 CaCO3 Tree"></a><a href="http://acm.scu.edu.cn/soj/problem.action?id=4616" target="_blank" rel="noopener">SOJ 4616 CaCO3 Tree</a></h3><h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><p>给定一棵n个结点的树和m条虚线边，求没有虚线连接到自身之外结点的子树个数<br>对于每一对虚线边的结点，结点到其LCA的每个点（除了LCA本身）为根结点的子树一定不符合要求统计未被标记的点的个数即是所求的子树个数<br>使用树上差分，由于LCA本身不标记，所以类似于对于边的差分，将差分数组的LCA结点-2，虚线边结点+1，从根结点dfs维护子树和，即可完成标记<br>ps:貌似卡读入</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">100005</span>;</span><br><span class="line"><span class="keyword">int</span> n,tot,a,b,n1;</span><br><span class="line"><span class="keyword">int</span> head[MAXN*<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> vis[MAXN];</span><br><span class="line"><span class="keyword">int</span> dep[MAXN];</span><br><span class="line"><span class="keyword">int</span> cnt[MAXN];</span><br><span class="line"><span class="comment">//int in[MAXN];</span></span><br><span class="line"><span class="comment">//int out[MAXN];</span></span><br><span class="line"><span class="keyword">int</span> f[MAXN][<span class="number">100</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to,next;</span><br><span class="line">&#125;edge[MAXN*<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> treenode[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="keyword">sizeof</span>(head));</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="built_in">memset</span>(dep,<span class="number">0</span>,<span class="keyword">sizeof</span>(dep));</span><br><span class="line">    <span class="built_in">memset</span>(cnt,<span class="number">0</span>,<span class="keyword">sizeof</span>(cnt));</span><br><span class="line">    tot=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    edge[tot].to=v;</span><br><span class="line">    edge[tot].next=head[u];</span><br><span class="line">    head[u]=tot++;</span><br><span class="line">    edge[tot].to=u;</span><br><span class="line">    edge[tot].next=head[v];</span><br><span class="line">    head[v]=tot++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> rt)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.push(rt);</span><br><span class="line">    f[rt][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    dep[rt]=<span class="number">1</span>;</span><br><span class="line">    vis[rt]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> fa=q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[fa];i!=<span class="number">-1</span>;i=edge[i].next)&#123;</span><br><span class="line">            <span class="keyword">int</span> v=edge[i].to;</span><br><span class="line">            <span class="keyword">if</span>(!vis[v])&#123;</span><br><span class="line">                dep[v]=dep[fa]+<span class="number">1</span>;</span><br><span class="line">                f[v][<span class="number">0</span>]=fa;</span><br><span class="line">                vis[v]=<span class="number">1</span>;</span><br><span class="line">                q.push(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cal_dep</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;(<span class="number">1</span>&lt;&lt;j)&lt;MAXN;j++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;MAXN;i++)&#123;</span><br><span class="line">            f[i][j]=f[f[i][j<span class="number">-1</span>]][j<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dep[u]&lt;dep[v])swap(u,v);</span><br><span class="line">    <span class="keyword">int</span> d=dep[u]-dep[v];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;(<span class="number">1</span>&lt;&lt;i)&lt;=MAXN;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>((<span class="number">1</span>&lt;&lt;i)&amp;d)u=f[u][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(u!=v)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=(<span class="keyword">int</span>)<span class="built_in">log</span>(MAXN);i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(f[u][i]!=f[v][i])&#123;</span><br><span class="line">                u=f[u][i];</span><br><span class="line">                v=f[v][i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[u][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">vis[u]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i!=<span class="number">-1</span>;i=edge[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> v=edge[i].to;</span><br><span class="line">        <span class="keyword">if</span>(!vis[v])&#123;</span><br><span class="line">            dfs(v);</span><br><span class="line">            cnt[u]+=cnt[v];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n)&#123;</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b);</span><br><span class="line">            addedge(a,b);</span><br><span class="line">        &#125;</span><br><span class="line">        bfs(<span class="number">1</span>);</span><br><span class="line">        cal_dep();</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;n1;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n1;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b);</span><br><span class="line">            cnt[a]++;</span><br><span class="line">            cnt[b]++;</span><br><span class="line">            <span class="keyword">int</span> k=lca(a,b);</span><br><span class="line">            cnt[k]-=<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">        dfs(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!cnt[i])&#123;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="SOJ-4631-CRY-cry"><a href="#SOJ-4631-CRY-cry" class="headerlink" title="SOJ 4631 CRY cry"></a><a href="http://acm.scu.edu.cn/soj/problem.action?id=4631" target="_blank" rel="noopener">SOJ 4631 CRY cry</a></h3><h4 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h4><p>对于给出的每一个1操作，将给的点分成同一种类的三个值，操作0对结果无影响，将所有点按照值的大小排序，使用双指针（不符合要求右指针右移，符合要求左指针右移到不符合要求为止）跑完整个序列，维护最小值,判断条件保持线性</p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">100005</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">  <span class="keyword">int</span> index;</span><br><span class="line">  <span class="keyword">int</span> val;</span><br><span class="line">&#125;node[MAXN*<span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Node a,Node b)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a.val&lt;b.val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> vis[MAXN*<span class="number">3</span>];</span><br><span class="line"><span class="keyword">int</span> n,a,b,c,d;</span><br><span class="line"><span class="keyword">int</span> tot,tott,zero_cnt,que;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n)&#123;</span><br><span class="line">    tot=<span class="number">0</span>;</span><br><span class="line">    tott=<span class="number">0</span>;</span><br><span class="line">    zero_cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">      <span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b;</span><br><span class="line">      <span class="keyword">if</span>(b==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;c&gt;&gt;d;</span><br><span class="line">        node[tot].index=tott;</span><br><span class="line">        node[tot++].val=a;</span><br><span class="line">        node[tot].index=tott;</span><br><span class="line">        node[tot++].val=a+c;</span><br><span class="line">        node[tot].index=tott++;</span><br><span class="line">        node[tot++].val=a-d;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span>&#123;</span><br><span class="line">        zero_cnt++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(node,node+tot,cmp);</span><br><span class="line">    <span class="comment">//cout&lt;&lt;node[0].val&lt;&lt;endl;</span></span><br><span class="line">    <span class="keyword">if</span>(zero_cnt==n)<span class="built_in">cout</span>&lt;&lt;<span class="number">0</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">int</span> flag=<span class="number">0</span>;</span><br><span class="line">    que=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;tott;k++)&#123;</span><br><span class="line">  vis[node[k].index]++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;tott;k++)&#123;</span><br><span class="line">  <span class="keyword">if</span>(!vis[k])&#123;</span><br><span class="line">  flag=<span class="number">1</span>;</span><br><span class="line">  que++;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(flag==<span class="number">0</span>)&#123;</span><br><span class="line">  ans=node[tott<span class="number">-1</span>].val-node[<span class="number">0</span>].val;</span><br><span class="line">  &#125;</span><br><span class="line">  j=tott<span class="number">-1</span>;</span><br><span class="line">  i=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(j&lt;tot)&#123;</span><br><span class="line">  <span class="keyword">while</span>(flag==<span class="number">1</span>&amp;&amp;j&lt;tot)&#123;</span><br><span class="line">  j++;</span><br><span class="line">  vis[node[j].index]++;</span><br><span class="line">  <span class="keyword">if</span>(vis[node[j].index]==<span class="number">1</span>)que--;</span><br><span class="line">  <span class="keyword">if</span>(que==<span class="number">0</span>)&#123;</span><br><span class="line">  flag=<span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(flag==<span class="number">0</span>&amp;&amp;j&lt;tot)&#123;</span><br><span class="line">  i++;</span><br><span class="line">  vis[node[i<span class="number">-1</span>].index]--;</span><br><span class="line">  <span class="keyword">if</span>(vis[node[i<span class="number">-1</span>].index]==<span class="number">0</span>)que++;</span><br><span class="line">  <span class="keyword">if</span>(que&gt;<span class="number">0</span>)&#123;</span><br><span class="line">  flag=<span class="number">1</span>;</span><br><span class="line">  ans=min(ans,node[j].val-node[i<span class="number">-1</span>].val);</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>支持向量机</title>
      <link href="/2019/04/19/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/"/>
      <url>/2019/04/19/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<h3 id="SVM简介"><a href="#SVM简介" class="headerlink" title="SVM简介"></a>SVM简介</h3><p>支持向量机(Support Vector Machine)是Cortes和Vapnik于1995年首先提出的，它在解决小样本、非线性及高维模式识别中表现出许多特有的优势，并能够推广应用到函数拟合等其他机器学习问题中。<br>支持向量机方法是建立在统计学习理论的VC 维理论和结构风险最小原理基础上的，根据有限的样本信息在模型的复杂性（即对特定训练样本的学习精度，Accuracy）和学习能力（即无错误地识别任意样本的能力）之间寻求最佳折衷，以期获得最好的推广能力。<br><br></p><h3 id="线性分类"><a href="#线性分类" class="headerlink" title="线性分类"></a>线性分类</h3><p>给定训练样本集 $ D=((x_1,y_1),(x_2,y_2),…,(x_m,y_m)),y_i\in\{-1,1\} $，线性分类器基于训练样本集D找到一个超平面 $ f(x)=W^Tx+b$ 区分两类数据。<br>当$ f(x)&gt;0 $时表示$ y=1 $的点，$ f(x)<0 $时表示$ y="-1" $的点，当$ f(x)="0" $时，表示该点在超平面上。当超平面距离两边的数据间距越大，则表示该超平面抗干扰性越好 <br></0></p><h3 id="支持向量"><a href="#支持向量" class="headerlink" title="支持向量"></a>支持向量</h3><p><br></p><script type="math/tex; mode=display">{w^Tx_i+b\geq1,y_i=1\atop w^Tx_i+b\leq-1,y_i=-1}</script><p><em>支持向量</em> 就是使得上式等号成立的，最靠近两条虚边界线的向量。<br>我们可以通过计算得到每一样本点$x$到超平面的距离为 $ r=\frac{|w^Tx+b|}{||w||} $<br>支持向量满足上述等式，由$w^Tx_0+b=0$($x_0$为垂点)可得 $ r=\frac{|w^Tx+b|}{||w||} $<br>推出 $ r=\frac{2}{||w||} $<br>得SVM的基本型</p><script type="math/tex; mode=display">max\frac{2}{||w||}\atop{s.t.y_i(w^Tx_i+b)\geq1,i=1,2,...,m}</script><p>等价于</p><script type="math/tex; mode=display">min\frac{1}{2}||w||^2\atop{s.t.y_i(w^Tx_i+b\geq,i=1,2,...m)}</script><p>使用拉格朗日乘数法求解</p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CodeForces 933A A Twisty Movement 题解</title>
      <link href="/2019/04/17/CodeForces_933A/"/>
      <url>/2019/04/17/CodeForces_933A/</url>
      
        <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>有一个由1和2构成的序列，你可以选择一个区间<a href="1≤ l ≤ r ≤ n">l,r</a>翻转，即这段区间就变成ar,ar-1,…,al+1,al。使得新序列中的non-decreasing subsequence最长。<br>一个长为k的non-decreasing subsequence是，一个满足下标p1 &lt; p2 &lt; … &lt; pk并且，ap1 ≤ ap2 ≤ … ≤ apk的子序列。</p><h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>第一行一个整数n (1 ≤ n ≤ 2000)，表示原串的长度。<br>第二行包含n个整数，表示a1, a2, …, an (1 ≤ ai ≤ 2, i = 1, 2, …, n)。</p><h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>Print a single integer, which means the maximum possible length of the longest non-decreasing subsequence of the new sequence.</p><h2 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h2><p>Input<br><code>4</code><br><code>1 2 1 2</code><br>Output<br><code>4</code><br>Input<br><code>10</code><br><code>1 1 2 2 2 1 1 2 2 1</code><br>Output<br><code>9</code></p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_N=<span class="number">2005</span>;</span><br><span class="line"><span class="keyword">int</span> n,ans;</span><br><span class="line"><span class="keyword">int</span> pre[MAX_N],nex[MAX_N],dp[MAX_N],a[MAX_N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">dp[i]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;i;++j)</span><br><span class="line"><span class="keyword">if</span>(a[j]&lt;=a[i]&amp;&amp;dp[j]+<span class="number">1</span>&gt;dp[i])</span><br><span class="line">                dp[i]=dp[j]+<span class="number">1</span>;</span><br><span class="line">pre[i]=max(dp[i],pre[i<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">dp[i]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=n;j&gt;i;j--)</span><br><span class="line"><span class="keyword">if</span>(a[j]&gt;=a[i]&amp;&amp;dp[j]+<span class="number">1</span>&gt;dp[i])</span><br><span class="line">                dp[i]=dp[j]+<span class="number">1</span>;</span><br><span class="line">nex[i]=max(dp[i],nex[i+<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        ans=max(ans,pre[i]+nex[i+<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>由于问题给出的数列只有1，2两个元素，所以我们所求的区间翻转后的LIS必然为若干个1接上若干个2.所以考虑该LIS在区间翻转前的状态一定为若干个1接上若干个2再接上若干个1和若干个2.所以要求翻转后的LIS的长度，就可以将整个序列分为两部分，前半部分求其正向非减的最大长度，后半部分求其逆向非增的最大长度，将其求和即可得到翻转后的LIS长度，最后求最大值即可。</p><h2 id="题目地址"><a href="#题目地址" class="headerlink" title="题目地址"></a>题目地址</h2><p><a href="http://codeforces.com/problemset/problem/933/A" target="_blank" rel="noopener">CodeForces 933A A Twisty Movement</a></p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
