<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>线性代数</title>
      <link href="/2020/03/06/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
      <url>/2020/03/06/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="向量方程"><a href="#向量方程" class="headerlink" title="向量方程"></a>向量方程</h3><p><strong>线性组合</strong>：给定$\mathbb{R}^n$中向量$\mathbf{v_1,v_2,…,v_p}$和标量$c_1,c_2,…,c_p$，向量</p><script type="math/tex; mode=display">\mathbf{y} = c_1\mathbf{v_1} +...+c_p\mathbf{v_p}</script><p>称为向量$\mathbf{v_1,v_2,…,v_p}$以$c_1,c_2,…,c_p$为<strong>权</strong>的<strong>线性组合</strong><br><strong>Span</strong>：若$\mathbf{v_1,v_2,…,v_p}$是$\mathbb{R}^n$中的向量，则$\mathbf{v_1,v_2,…,v_p}$的所有线性组合所成的集合用记号$\mathbf{Span}\begin{Bmatrix}\mathbf{v_1,v_2,…,v_p}\end{Bmatrix}$表示，称为<strong>由$\mathbf{v_1,v_2,…,v_p}$所生成（张成）的$\mathbb{R}^n$的子集</strong>。也就是说，$\mathbf{Span}\begin{Bmatrix}\mathbf{v_1,v_2,…,v_p}\end{Bmatrix}$是所有形如</p><script type="math/tex; mode=display">c_1\mathbf{v_1} + c_2\mathbf{v_2} +...+c_p\mathbf{v_p}</script><p>的向量的集合，其中$c_1,c_2,…,c_p$为标量</p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>多元函数微分</title>
      <link href="/2020/02/26/%E5%A4%9A%E5%85%83%E5%87%BD%E6%95%B0%E5%BE%AE%E5%88%86/"/>
      <url>/2020/02/26/%E5%A4%9A%E5%85%83%E5%87%BD%E6%95%B0%E5%BE%AE%E5%88%86/</url>
      
        <content type="html"><![CDATA[<h3 id="全微分"><a href="#全微分" class="headerlink" title="全微分"></a>全微分</h3><p><strong>定义</strong>：设函数$z=f(x, y)$，点$(x_0, y_0)$的某邻域内有定义，如果函数在点$(x_0, y_0)$的全增量可以表示为</p><script type="math/tex; mode=display">\Delta z = A\Delta x + B\Delta y + o(\rho)</script><p>其中$\rho = \sqrt{(\Delta x)^2 + (\Delta y)^2}$，$A, B$是不依赖与$\Delta x, \Delta y$的两个常数，则称函数$z = f(x, y)$在点$(x_0, y_0)$可微分或可微，并称$A\Delta x + B\Delta y$为函数$z = f(x, y)$在点$(x_0, y_0)$的<strong>全微分</strong>，记作$\mathrm{d}z$，即</p><script type="math/tex; mode=display">\mathrm{d}z = A\Delta x + B\Delta y</script><p><strong>定理1</strong>：若函数$z=f(x, y)$在点$(x_0, y_0)$可微，则函数在点$(x_0, y_0)$处的两个偏导数$\cfrac{\partial z}{\partial x}, \cfrac{\partial z}{\partial y}$存在，且$\mathrm{d}z = \cfrac{\partial z}{\partial x}\mathrm{d}x + \cfrac{\partial z}{\partial y}\mathrm{d}y$<br><strong>定理2</strong>：若函数$z=f(x, y)$的偏导数$f_x(x, y),f_y(x, y)$在点$(x, y)$连续，则函数$z = f(x, y)$在点$(x, y)$可微</p><h3 id="符合函数的求导法则"><a href="#符合函数的求导法则" class="headerlink" title="符合函数的求导法则"></a>符合函数的求导法则</h3><p><strong>链式法则</strong>：</p><script type="math/tex; mode=display">\cfrac{\mathrm{d}y}{\mathrm{d}x} = \cfrac{\mathrm{d}y}{\mathrm{d}u}\cdot \cfrac{\mathrm{d}u}{\mathrm{d}x} = f'(u)u'(x) = f'(\phi(x))\phi '(x)</script><p><strong>求导法则</strong>：设函数$z = f(u, v)$在$(u, v)$可微，$u = u(x, y), v = v(x, y)$在点$(x, y)$处可偏导，则复合函数$z = f[u(x, y), v(x, y)]$在点$(x, y)$的偏导数存在，且</p><script type="math/tex; mode=display">\begin{cases} \cfrac{\partial z}{\partial x} = \cfrac{\partial z}{\partial u} \cdot \cfrac{\partial u}{\partial x} + \cfrac{\partial z}{\partial v} \cdot \cfrac{\partial v}{\partial x}\\ \cfrac{\partial z}{\partial y} = \cfrac{\partial z}{\partial u} \cdot \cfrac{\partial u}{\partial y} + \cfrac{\partial z}{\partial v} \cdot \cfrac{\partial v}{\partial y} \end{cases}</script><h3 id="方向导数和梯度"><a href="#方向导数和梯度" class="headerlink" title="方向导数和梯度"></a>方向导数和梯度</h3><p><strong>方向导数</strong>：设函数$z=f(x, y)$在点$P_0(x_0, y_0)$的某邻域内有定义，$\boldsymbol{l}$为字典$P_0(x_0, y_0)$发出的射线方向，$\boldsymbol{l}^o = (\cos\alpha, \cos\beta)$是与$\boldsymbol{l}$同方向的单位向量，如果</p><script type="math/tex; mode=display">\lim\limits_{\rho \to 0^+} \cfrac{f(x_0 + \rho\cos\alpha, y_0 + \rho\cos\beta) - f(x_0, y_0)}{\rho}</script><p>存在，则称此极限为函数$z=f(x, y)$在点$P_0{x_0, y_0}$沿方向$\boldsymbol{l}$的<strong>方向导数</strong>，记作</p><script type="math/tex; mode=display">\cfrac{\partial f}{\partial \boldsymbol{l}}(x_0, y_0)\,\,\,或\,\,\,f_\boldsymbol{l}(x_0, y_0)</script><p>同理，设$P(x_0 + \Delta x, y_0 + \Delta y)$为方向射线上的动点，上述极限可改写为</p><script type="math/tex; mode=display">\lim\limits_{\Delta x \to 0  \\ \Delta y \to 0}\cfrac{f(x_0 + \Delta x, y_0 + \Delta y) - f(x_0, y_0)}{\sqrt{\Delta x^2 + \Delta y^2}}</script><p><strong>方向导数的计算</strong>：设函数$z=f(x, y)$在点$P(x_0, y_0)$处可微，则函数$z=f(x, y)$在点$P(x_0, y_0)$处沿任意方向$\boldsymbol{l}^o=(\cos\alpha, \cos\beta)$的方向导数都存在，且</p><script type="math/tex; mode=display">\cfrac{\partial f}{\partial \boldsymbol{l}}|_{(x_0, y_0)} = f_x(x_0, y_0)\cos\alpha + f_y(x_0, y_0)\cos\beta</script><p><strong>梯度</strong>：设函数$z=f(x, y)$在点$(x_0, y_0)$处可偏导，称向量$(f_x(x_0, y_0), f_y(x_0, y_0))$为函数$z=f(x, y)$在点$(x_0, y_0)$处的<strong>梯度</strong>，记作</p><script type="math/tex; mode=display">\mathrm{grad} f(x_0, y_0)\,或\,\nabla f(x_0, y_0)</script><p>函数$z=f(x, y)$沿方向$\boldsymbol{l}^o$的方向导数可以改写为</p><script type="math/tex; mode=display">\cfrac{\partial f}{\partial \boldsymbol{l}} = |\mathrm{grad}f| \cdot \cos\theta</script><p>其中$\theta$为梯度$\cfrac{\partial f}{\partial \boldsymbol{l}}$与方向$\boldsymbol{l}^o$之间的夹角</p><h3 id="多元函数的极值"><a href="#多元函数的极值" class="headerlink" title="多元函数的极值"></a>多元函数的极值</h3><p><strong>极值的必要条件</strong>：若函数$z=f(x, y)$在点$P_0(x_0, y_0)$取得极值，并且$z=f(x, y)$在点$(x_0, y_0)$处可偏导，则</p><script type="math/tex; mode=display">f_x(x_0, y_0) = 0,\,\,f_y(x_0, y_0) = 0</script><p><strong>极值的充分条件</strong>：设$z=f(x, y)$在点$P_0(x_0, y_0)$的某邻域内具有一阶及二阶连续偏导数，有$f_x(x_0, y_0)=0, f_y(x_0, y_0)=0$，令</p><script type="math/tex; mode=display">A = f_{xx}(x_0, y_0),\,B = f_{xy}(x_0, y_0),\,C = f_{yy}(x_0, y_0),\,\nabla = B^2 - AC</script><p>那么：<br>（1）若$\nabla &lt; 0, A &lt; 0$，则函数$z = f(x, y)$在点$(x_0, y_0)$取得极大值<br>（2）若$\nabla &lt; 0, A &gt; 0$，则函数$z = f(x, y)$在点$(x_0, y_0)$取得极小值<br>（3）若$\nabla &gt; 0$，则函数$z = f(x, y)$在点$(x_0, y_0)$取不到极值<br>（4）若$\nabla = 0$，则函数$z = f(x, y)$在点$(x_0, y_0)$可能取得极值也可能取不到极值</p><h3 id="拉格朗日条件极值"><a href="#拉格朗日条件极值" class="headerlink" title="拉格朗日条件极值"></a>拉格朗日条件极值</h3><p><strong>无约束条件</strong>：令导函数=0，将可能的极值点回代验证<br><strong>等式约束条件(拉格朗日乘子法)</strong>：条件极值的一般形式为：</p><script type="math/tex; mode=display">\begin{cases}\min f(x, y) \\ \mathrm{s.t.}\quad \varphi(x, y) = 0\end{cases}\quad 或 \quad \begin{cases}\max f(x, y) \\ \mathrm{s.t.}\quad \varphi(x, y) = 0\end{cases}</script><p>做拉格朗日目标函数</p><script type="math/tex; mode=display">L(x, y, \lambda) = f(x, y) + \lambda \varphi (x, y)</script><p>其中$\lambda$称为<strong>拉格朗日乘数</strong><br>求出各个偏导数并令其为0，解出驻点，回代验证，可以推广至多元函数情况<br><strong>不等式约束条件(KKT条件)</strong>：将约束等式推广为约束不等式，其一般形式为：</p><script type="math/tex; mode=display">\begin{cases}\min f(x) \\ \mathrm{s.t.}\quad g_i(x) \le 0, i = 1, 2, ..., m\ \\ \quad\quad\,\,\, h_i(x) = 0, i = 1, 2, ..., p \end{cases}</script><p>作拉格朗日函数转化为无约束问题</p><script type="math/tex; mode=display">L(x, \lambda, \eta) = f(x) + \sum\limits_i^m \lambda_i g_i(x) + \sum\limits_i^p \eta_i h_i(x)</script><p>我们将约束不等式称为<strong>原始可行性(primal feasibility)</strong>，讨论最优解的位置<br>（1）当最优解在不等式可行域的内部时，$g(x)$的约束无效，称为内部解<br>（2）当最优解在不等式可行域的边界时，$g(x)$的约束有效，称为边界解<br>内部解则该问题退化成无约束条件（不考虑$h(x)$），$\lambda = 0$<br>边界解，则$g(x) = 0$，解法则参考等式约束条件，令拉格朗日函数的导数为0，即</p><script type="math/tex; mode=display">\nabla f(x) + \sum\limits_i^m \lambda_i \nabla g_i(x) + \sum\limits_i^p \eta_i \nabla h_i(x) = 0</script><p>对每个约束条件我们都能作出单独的拉格朗日函数，所以对于任意一个不等式约束条件$g(x) \le 0$，可以得到</p><script type="math/tex; mode=display">\nabla f(x) + \lambda g(x) \\ 即 \nabla f(x) = -\lambda \nabla g(x)</script><p>当前情况求$f(x)$的最小值，所以可行域内所有的$f$都更大，所以$f$的梯度应该指向可行域内部，而约束条件$g(x) \le 0$，所以$g$的梯度应该指向可行域外，所以得出$\lambda \ge 0$，由此推出<br><strong>对偶可行性(dual feasibility)</strong>：$\lambda_i \ge 0, i = 1, 2, …, m$（易得，当目标函数为求取$f$的最大值时$\lambda_i \le 0$）<br>由已知最优解在内部时$\lambda = 0$，最优解在边界时$g(x) = 0$，可以推出<br><strong>互补松弛性(complementary slackness)</strong>：$\lambda_i g_i(x) = 0$<br>综上所述，原始可行性、对偶可行性、互补松弛性合起来就是<strong>KKT(Karush-Kuhn-Tucker)条件</strong>，记作</p><script type="math/tex; mode=display">\begin{cases} \nabla_x L = 0 \\ h_i(x) = 0, i = 1, 2, ..., p\\g_i(x) \le 0 \\ \lambda_i \ge 0\\ \lambda_i g_i(x) = 0, i = 1, 2, ..., m\end{cases}</script><p><strong>规范性条件(Regularity conditions)</strong>：满足KKT条件要求约束条件的质量不能太差，常见的比如：<br>LCQ：如果$g(x)$和$h(x)$都是形如$Ax + b$的仿射函数，那么极值一定满足KKT条件。<br>LICQ：起作用的$g(x)$函数（即$g(x) \le 0$相当于等式约束的情况）和$h(x)$函数在极值点处的梯度要线性无关，那么极值一定满足 KKT 条件。<br>Slater条件：如果优化问题是个凸优化问题，且至少存在一个点满足$h(x) = 0$和$g(x) = 0$，极值一定满足KKT条件。并且满足强对偶性质。</p><h3 id="拉格朗日对偶性"><a href="#拉格朗日对偶性" class="headerlink" title="拉格朗日对偶性"></a>拉格朗日对偶性</h3><p><strong>对偶问题</strong>：首先提出问题的一般形式：</p><script type="math/tex; mode=display">\begin{cases}\min f(x) \\ \mathrm{s.t.}\quad g_i(x) \le 0, i = 1, 2, ..., m\ \\ \quad\quad\,\,\, h_i(x) = 0, i = 1, 2, ..., p \end{cases}</script><p>作拉格朗日函数转化为无约束问题</p><script type="math/tex; mode=display">L(x, \lambda, \eta) = f(x) + \sum\limits_i^m \lambda_i g_i(x) + \sum\limits_i^p \eta_i h_i(x)</script><p>为了简化计算，对拉格朗日函数关于$\lambda, \eta$的最大值函数</p><script type="math/tex; mode=display">\theta_P(x) = \max\limits_{\lambda \ge 0,\eta} L(x, \lambda, \eta)</script><p>此处求$f$的最小值所以$\lambda \ge 0$， 原因当$x$满足约束时，$L(x, \lambda, \eta)$关于$\lambda,\eta$的最大值必然为$f(x)$；同理，当求$f$的最大值时$\lambda \le 0$，当$x$满足约束时，$L(x, \lambda, \eta)$关于$\lambda,\eta$的最小值必然为$f(x)$，数学表示如下：</p><script type="math/tex; mode=display">\min\limits_x L(x, \lambda, \eta) = \min\limits_x \theta_P(x) = \min\limits_x\,\max\limits_{\lambda \ge 0,\eta} L(x, \lambda, \eta) \\ \max\limits_x L(x, \lambda, \eta) = \max\limits_x \theta_P(x) = \max\limits_x\,\min\limits_{\lambda \le 0,\eta} L(x, \lambda, \eta)</script><p>接下来只分析求最小值的情况，$\min\limits_x\,\max\limits_{\lambda \ge 0,\eta} L(x, \lambda, \eta)$与原问题完全等价，称为拉格朗日函数的极小极大问题，也被称为<strong>原始问题(Primal Problem)</strong>，其<strong>对偶问题(Dual Problem)</strong> 拉格朗日函数的极大极小问题表示如下：</p><script type="math/tex; mode=display">\theta_D(\lambda,\eta) = \min\limits_x L(x, \lambda, \eta) \\ \max\limits_{\lambda \ge 0,\eta} \theta_D(\lambda,\eta) = \max\limits_{\lambda \ge 0,\eta}\, \min\limits_x L(x, \lambda, \eta)</script><p>将其展开为约束最优化问题</p><script type="math/tex; mode=display">\max\limits_{\lambda,\eta} \theta_D(\lambda,\eta) = \max\limits_{\lambda,\eta}\, \min\limits_x L(x, \lambda, \eta) \\ \mathrm{s.t.}\quad i = 1, 2, ..., m</script><p><strong>弱对偶与强对偶</strong>：关于原始问题和对偶问题，可以得到不等式</p><script type="math/tex; mode=display">\theta_D(\lambda,\eta) = \min\limits_x L(x, \lambda, \eta) \le L(x, \lambda, \eta) \le \max\limits_{\lambda \ge 0,\eta} L(x, \lambda, \eta) = \theta_P(x)</script><p>可以得到<strong>弱对偶性</strong></p><script type="math/tex; mode=display">d^* = \max\limits_{\lambda,\eta} \theta_D(\lambda,\eta) \le \min\limits_x \theta_P(x) = p^*</script><p>而<strong>强对偶性</strong>，即 $d^* = p^*$<br><strong>强对偶的必要条件(KKT条件)</strong>:假设取到极值的点为$x^*,\lambda^*,\eta^*$<br>首先有</p><script type="math/tex; mode=display">\nabla_x L = 0, 即\quad\nabla f(x^*) + \sum\limits_i^m \lambda_i \nabla g_i(x^*) + \sum\limits_i^p \eta_i \nabla h_i(x^*) = 0</script><p>根据不等式</p><script type="math/tex; mode=display">d^* = \min\limits_x L(x, \lambda^*, \eta^*) \le L(x^*, \lambda^*, \eta^*) = f(x^*) + \sum\limits_i^m \lambda_i g_i(x^*) + \sum\limits_i^p \eta_i h_i(x^*) \le p^* = f(x^*)</script><p>因为满足强对偶性，即</p><script type="math/tex; mode=display">d^* = p^*</script><p>有</p><script type="math/tex; mode=display">\sum\limits_i^m \lambda_i g_i(x^*) + \sum\limits_i^p \eta_i h_i(x^*) = 0</script><p>又有约束条件：</p><script type="math/tex; mode=display">h_i(x) = 0, i = 1, 2, ..., p</script><p>得到</p><script type="math/tex; mode=display">\lambda_i g_i(x) = 0, i = 1, 2, ..., m</script><p>由原始问题的极小极大和对偶问题的极大极小可以得到</p><script type="math/tex; mode=display">\lambda_i \ge 0, i = 1, 2, ..., m</script><p>综上所述，推出KKT条件，其必要性证毕<br><strong>强对偶的充分条件(凸函数的KKT条件)</strong>：<br>根据不等式</p><script type="math/tex; mode=display">d^* = \min\limits_x L(x, \lambda^*, \eta^*) \le L(x^*, \lambda^*, \eta^*) = f(x^*) + \sum\limits_i^m \lambda_i g_i(x^*) + \sum\limits_i^p \eta_i h_i(x^*) \le p^* = f(x^*)</script><p>满足KKT条件时</p><script type="math/tex; mode=display">d^* = \min\limits_x L(x, \lambda^*, \eta^*) \le L(x^*, \lambda^*, \eta^*) = f(x^*) + \sum\limits_i^m \lambda_i g_i(x^*) + \sum\limits_i^p \eta_i h_i(x^*) = p^* = f(x^*)</script><p>又因为$L(x, \lambda^*, \eta^*)$为凸函数，当满足$\nabla_x L = 0$时，$L(x^*, \lambda^*, \eta^*)$为最小值，即</p><script type="math/tex; mode=display">d^* = \min\limits_x L(x, \lambda^*, \eta^*) = L(x^*, \lambda^*, \eta^*) = f(x^*) + \sum\limits_i^m \lambda_i g_i(x^*) + \sum\limits_i^p \eta_i h_i(x^*) = p^* = f(x^*) \\ d^* = p^*</script><p>充分性证毕</p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>不定积分与定积分</title>
      <link href="/2020/02/22/%E4%B8%8D%E5%AE%9A%E7%A7%AF%E5%88%86%E4%B8%8E%E5%AE%9A%E7%A7%AF%E5%88%86/"/>
      <url>/2020/02/22/%E4%B8%8D%E5%AE%9A%E7%A7%AF%E5%88%86%E4%B8%8E%E5%AE%9A%E7%A7%AF%E5%88%86/</url>
      
        <content type="html"><![CDATA[<h3 id="黎曼和与定积分"><a href="#黎曼和与定积分" class="headerlink" title="黎曼和与定积分"></a>黎曼和与定积分</h3><p><strong>概念</strong>：设函数$f(x)$在闭区间$[a, b]$上有定义，在该闭区间上插入一系列分点：</p><script type="math/tex; mode=display">a = x_0 < ... < x_{i-1} < x_i < ... < x_n = b</script><p>将至划分为$n$个小区间，并在每一个小区间$[x_{i-1}, x_i]$上任意取一个点$\xi_i \in [x_{i-1}, x_i]$，作和式（即<strong>黎曼和</strong>或<strong>积分</strong>）</p><script type="math/tex; mode=display">\sum\limits_{i=1}^nf(x_i)\Delta x_i</script><p>这里$\Delta x_i = x_i - x_{i - 1}$是第$i$个小区间的长度。如果存在一个数$P$，满足：对于任意小的正实数$\varepsilon &gt; 0$，都存在另一个正实数$\varphi &gt; 0$，使得所有划分中，只要他的最大小区间的长度小于$\varphi$，那么无论怎么选取各个小区间上的$\xi_i$的值，都有：</p><script type="math/tex; mode=display">|\sum\limits_{i=1}^nf(\xi_i) \Delta x_i - P|</script><p>那么就称函数$f(x)$在闭区间$[a, b]$上<strong>可积</strong>，$P$称为函数$f(x)$在闭区间$[a, b]$上的定积分值，符号表示：</p><script type="math/tex; mode=display">P = \int_{a}^{b} f(x)\, \mathrm{d}x</script><p>其中的$a, b$称为积分上限和积分下限</p><h3 id="可积条件"><a href="#可积条件" class="headerlink" title="可积条件"></a>可积条件</h3><p><strong>达布和</strong>：设函数$f(x)$在闭区间$[a, b]$上有定义，对于该闭区间的某个划分：</p><script type="math/tex; mode=display">a = x_0 < ... < x_{i-1} < x_i < ... < x_n = b</script><p>设$f(x)$在每个小区间$[x_{i-1}, x_i]$上的上确界为$M_i$，下确界为$m_i$，作和式：</p><script type="math/tex; mode=display">s = \sum\limits_{i=1}^nm_i\Delta x_i</script><p>称为<strong>下积分和</strong>，再作和式</p><script type="math/tex; mode=display">S = \sum\limits_{i=1}^n M_i\Delta x_i</script><p>称为<strong>上积分和</strong>，上积分和与下积分和都成为<strong>达布和</strong><br>在每个小区间$[x_{i-1}, x_i]$上任意取定点$\xi_i$，有</p><script type="math/tex; mode=display">m_i \le f(\xi_i) \le M_i</script><p>因此有</p><script type="math/tex; mode=display">\sum\limits_{i=1}^nm_i\Delta x_i \le \sum\limits_{i=1}^nf(\xi_i)\Delta x_i \le \sum\limits_{i=1}^nM_i\Delta x_i</script><p><strong>性质1</strong>：如果在分划中增加一些新的分点，那么上积分和不会增加，下积分和不会减小<br><strong>性质2</strong>：上积分和永远不小于下积分和，无论是对于同一个划分还是不同的划分均是如此<br><strong>可积条件1</strong>：函数$f(x)$在闭区间上可积的充分必要条件是：</p><script type="math/tex; mode=display">\lim\limits_{\lambda \to 0}(S - s) = 0</script><p>$\lambda$表示划分下的各小区间的最大长度<br><strong>可积条件2</strong>：函数$f(x)$在闭区间上可积的充分必要条件是：</p><script type="math/tex; mode=display">\lim\limits_{\lambda \to 0} \omega_i\Delta x_i = 0</script><p>$\lambda$表示划分下的各小区间的最大长度，$\omega_i = M_i - m_i$(小区间上下确界的振幅)<br><strong>上积分与下积分</strong>：上积分和的下确界称为<strong>上积分</strong>，记作$ I^* $，下积分和的上确界称为<strong>下积分</strong>，记作$ I_* $<br>上积分是上积分和的极限，下积分是下积分和的极限，即：</p><script type="math/tex; mode=display">I^* = \lim\limits_{\lambda \to 0}S, I_* = \lim\limits_{\lambda \to 0}s</script><p>$\lambda$表示划分下的各小区间的最大长度<br><strong>可积条件3</strong>：函数在闭区间上可积的充分必要条件是：上积分与下积分相等，即：</p><script type="math/tex; mode=display">I^* = I_*</script><p>并且在上下积分相等的情况下，这个值就是定积分的值</p><h3 id="可积函数与不可积函数"><a href="#可积函数与不可积函数" class="headerlink" title="可积函数与不可积函数"></a>可积函数与不可积函数</h3><p><strong>定理1</strong>：闭区间上的连续函数总是可积的<br><strong>定理2</strong>：如果函数在闭区间上只有有限多个间断点，那么它是可积的<br><strong>定理3</strong>：函数$f(x)$在闭区间上可积的充分必要条件是：对于任意小的两个正实数$\varepsilon &gt; 0, \sigma &gt; 0$，都存在一个很小的正实数$\varphi&gt;0$，使得任何一个最大小区间长度小于$\varphi$的划分都满足：振幅大于$\varepsilon$的小区间长度总和不超过$\sigma$<br><strong>定理4</strong>：如果函数在闭区间上单调有界，则它是可积的</p><h3 id="不定积分的概念和性质"><a href="#不定积分的概念和性质" class="headerlink" title="不定积分的概念和性质"></a>不定积分的概念和性质</h3><p><strong>原函数</strong>：如果在区间$I$上，对已知的函数$f(x)$，若$\forall x \in I$，存在$F(x)$，使得$F’(x) = f(x)$或$\mathrm{d}F(x) = f(x)\,\mathrm{d}x$，则称函数$F(x)$为$f(x)$在区间$I$上的一个原函数，$F(x) + C$是$f(x)$在区间$I$上的全体原函数，$C$为任意常数。<br><strong>不定积分</strong>：函数$f(x)$在区间$I$上的全体原函数称为$f(x)$在区间$I$上的不定积分，记作$\int f(x)\,\mathrm{d}x$，即</p><script type="math/tex; mode=display">\int f(x)\,\mathrm{d}x = F(x) + C</script><p><strong>性质1</strong>：$\int kf(x)\,\mathrm{d}x = k\int f(x)\,\mathrm{d}x\,(k \ne 0)$<br><strong>性质2</strong>：设$f(x),g(x)$的原函数存在，则</p><script type="math/tex; mode=display">\int [f(x) + g(x)]\,\mathrm{d}x = \int f(x)\,\mathrm{d}x + \int g(x)\,\mathrm{d}x</script><p><strong>性质3</strong>：设$f_(x),f_2(x),…,f_n(x)$的原函数存在，且$k_1,k_2,…,k_n$是常数，则</p><script type="math/tex; mode=display">\int [k_1f_1(x) + k_2f_2(x) + ... + k_nf_n(x)]\,\mathrm{d}x = k_1\int f_1(x)\,\mathrm{d}x + k_2\int f_2(x)\,\mathrm{d}x + ... + k_n\int f_n(x)\,\mathrm{d}x</script><h3 id="定积分的性质"><a href="#定积分的性质" class="headerlink" title="定积分的性质"></a>定积分的性质</h3><p><strong>线性性质</strong>：若函数$f_1(x),f_2(x)$在$[a, b]$上可积，$\forall k_1,k_2 \in \mathbb{R}$，则函数在上可积，且</p><script type="math/tex; mode=display">\int_a^b [k_1f_1(x) + k_2f_2(x)]\,\mathrm{d}x = k_1\int_a^b f_1(x)\,\mathrm{d}x + k_2\int_a^b f_2(x)\,\mathrm{d}x</script><p><strong>区间可加性</strong>：设$I$为一个有限闭区间，$a,b,c\in I$，若$f(x)$在$I$上可积，则$f(x)$在$[a, b],[a, c],[c, b]$上均可积，且</p><script type="math/tex; mode=display">\int_a^b f(x)\,\mathrm{d}x = \int_a^c f(x)\,\mathrm{d}x + \int_c^b f(x)\,\mathrm{d}x</script><p><strong>积分中值定理</strong>：若函数$f(x)$在闭区间$[a, b]$上连续，则在区间$[a, b]$上至少存在一点$\xi$，使得</p><script type="math/tex; mode=display">\int_a^bf(x)\,\mathrm{d}x = f(\xi)(b-a),(a \le \xi \le b)</script><p><strong>积分中值定理推广</strong>：若函数$f(x)$在闭区间$[a, b]$上连续，函数$g(x)$在区间$[a, b]$上可积且不变号，则在区间$[a, b]$上至少存在一点$\xi$，使得</p><script type="math/tex; mode=display">\int_a^bf(x)g(x)\,\mathrm{d}x = f(\xi)\int_a^bg(x)\,\mathrm{d}x,</script>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>导数与微分</title>
      <link href="/2020/02/13/%E5%AF%BC%E6%95%B0%E4%B8%8E%E5%BE%AE%E5%88%86/"/>
      <url>/2020/02/13/%E5%AF%BC%E6%95%B0%E4%B8%8E%E5%BE%AE%E5%88%86/</url>
      
        <content type="html"><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p><strong>导数的定义</strong>：设函数$f(x)$在$x_0$的某邻域内有定义，如果极限$\lim\limits_{x \to x_0}\cfrac{f(x) - f(x_0)}{x - x_0}$存在，则称函数$f(x)$在$x_0$处可导，也称可微，此极限值$f(x_0)$称为在$x_0$处的导数，并记为$f’(x)$，或称为<em>微商</em>，记为$\frac{\mathrm{d}y}{\mathrm{d}x}|_{x = x_0}$，即</p><script type="math/tex; mode=display">f'(x_0) =\frac{\mathrm{d}y}{\mathrm{d}x}|_{x = x_0} = \lim\limits_{x \to x_0}\cfrac{f(x) - f(x_0)}{x - x_0}</script><p>如果前述极限不存在，则称函数在该点不可导，类似的，把极限过程分别替换为左极限和右极限，就得出<strong>左导数</strong>$f’_-(x_0)$和<strong>右导数</strong>$f’_+(x_0)$的概念，即</p><script type="math/tex; mode=display">f'_-(x_0) = \lim\limits_{x \to x_0^-}\cfrac{f(x) - f(x_0)}{x - x_0},\quad f'_+(x_0) = \lim\limits_{x \to x_0^+}\cfrac{f(x) - f(x_0)}{x - x_0}</script><p>显然，函数在某点可导的充分必要条件是，该点既左可导又右可导，且左右导数相等。如果函数在某点可导，则函数必在该点连续。<br><strong>导函数的定义</strong>：如果函数$f(x)$在某个区间上有定义，并且在该区间上处处可导（闭区间上的端点处只要单侧可导），则称函数在该区间上可导，而自由变量映射导数值构成一个新的函数$f’(x)$，称为函数$f(x)$的导函数。</p><h3 id="求导法则"><a href="#求导法则" class="headerlink" title="求导法则"></a>求导法则</h3><p><strong>定理1</strong>：设函数$f(x)$和$g(x)$在$x_0$的某个邻域内有定义且在$x_0$处可导，则函数$u(x) = f(x) + g(x)$和$v(x) = f(x) - g(x)$在$x_0$处也可导，并且</p><script type="math/tex; mode=display">u'(x_0) = f'(x_0) + g'(x_0), v'(x_0) = f'(x_0) - g'(x_0)</script><p><strong>定理2</strong>：设函数$f(x)$和$g(x)$在$x_0$的某个邻域内有定义且在$x_0$处可导，则函数$u(x) = f(x)g(x)$在$x_0$处也可导，并且</p><script type="math/tex; mode=display">u'(x_0) = f'(x_0)g(x_0) + f(x_0)g'(x_0)</script><p><strong>定理3</strong>：设若干个函数$f_i(x)(i = 1, 2,…,n)$在$x_0$的某个邻域内有定义且在$x_0$处可导，则函数$P(x) = \prod_\limits{i=1}^n f_i(x)$在$x_0$处也可导，并且</p><script type="math/tex; mode=display">P'(x_0) = \prod_\limits{i=1}^n f_i(x_0) \sum\limits_{i=1}^n \cfrac{f'_i(x_0)}{f_i(x_0)}</script><p><strong>定理4</strong>：设函数$f(x)$在$x_0$的某个邻域内有定义且在$x_0$处可导，则函数$u(x) = \cfrac{1}{f(x)}$在$x_0$处也可导，且有：</p><script type="math/tex; mode=display">u'(x) = - \cfrac{f'(x_0)}{f^2(x_0)}</script><p><strong>定理5</strong>：设函数$f(x)$和$g(x)$在$x_0$的某个邻域内有定义且在$x_0$处可导，$g(x) \ne 0$，则函数$u(x) = \cfrac{f(x)}{g(x)}$在$x_0$处也可导，且有：</p><script type="math/tex; mode=display">u'(x) = \cfrac{f'(x_0)g(x_0) - f(x_0)g'(x_0)}{g^2(x_0)}</script><p><strong>反函数的导数</strong>：如果函数$f(x)$在$x_0$的某个邻域上严格单调，且在$x_0$处存在非零的导数，则其反函数$x = \varphi(y)$在$y_0 = f(x_0)$处亦可导，且导数值</p><script type="math/tex; mode=display">\varphi'(y_0) = \cfrac{1}{f'(x_0)}</script><p><strong>复合函数的导数</strong>：设函数$u=\varphi(x)$在$x_0$处可导，而函数$y=f(u)$在$u_0=\varphi(x)$处亦可导，且$y=f(u)$在$u_0$的某空心邻域内函数值恒不与$f(u)$相同，则复合函数$y=f(\varphi(x))$在$x_0$处可导，且导数值为$f’(u_0)\varphi’(x_0)$</p><h3 id="求导公式表"><a href="#求导公式表" class="headerlink" title="求导公式表"></a>求导公式表</h3><div class="table-container"><table><thead><tr><th>分类</th><th>公式</th></tr></thead><tbody><tr><td>常函数</td><td>$(C)’=0$</td></tr><tr><td>幂函数</td><td>$(x^p)’=px^{p-1},(p\in\mathbb{R},x&gt;0)$</td></tr><tr><td>指数函数，对数函数</td><td>$(a^x)’=a^x\ln a$, $(\log_ax)’=\cfrac{\log_ae}{x}$, 特殊情况：$(e^x)’=e^x$, $(\ln x)’=\frac{1}{x}$</td></tr><tr><td>三角函数，反三角函数</td><td>$(\sin x)’ = \cos x$, $(\cos x)’=-\sin x$, $(\tan x)’=\sec ^2x$, $(\arcsin x)’=\cfrac{1}{\sqrt{1-x^2}}$, $(\arccos x)’=-\cfrac{1}{\sqrt{1-x^2}}$, $(\arctan x)’=\cfrac{1}{1+x^2}$</td></tr></tbody></table></div><h3 id="莱布尼茨公式"><a href="#莱布尼茨公式" class="headerlink" title="莱布尼茨公式"></a>莱布尼茨公式</h3><p><strong>莱布尼茨公式</strong>：设函数$f(x)$与$g(x)$都在某个共同的区间上存在直到$n$阶的导函数，则乘积$h(x)=f(x)g(x)$的$n$阶导数是</p><script type="math/tex; mode=display">h^{(n)}(x) = \sum\limits_{i=0}^nC_n^if^{(n-i)}(x)g^{(i)}(x)</script><h3 id="微分"><a href="#微分" class="headerlink" title="微分"></a>微分</h3><p><strong>概念</strong>：设函数$f(x)$在$x_0$的某邻域内有定义，如果存在常数$A$，使得当自变量增量$\Delta x$趋于0时，函数值增量$\Delta y$与$A\Delta x$相差一个$\Delta x$的高阶无穷小，即</p><script type="math/tex; mode=display">\Delta y = A\Delta x + o(\Delta x)</script><p>则称函数$f(x)$在$x_0$处可微，而表达式$A\Delta x$就称为函数$f(x)$在$x_0$处的微分，记作$\mathrm{d}y|_{x=x_0}$或者$\mathrm{d}f(x_0)$<br>微分概念的核心就是<strong>从无穷小中分离出最主要的线性部分</strong>，这部分就是函数的微分，$f’(x_0) = \cfrac{\mathrm{d}y}{\mathrm{d}x}$<br><strong>高阶微分</strong>：</p><script type="math/tex; mode=display">\mathrm{d}y=f'(x)\mathrm{d}x</script><script type="math/tex; mode=display">\mathrm{d}^2y = d(f'(x)\mathrm{d}x) = d(f'(x))\mathrm{d}x = f''(x)\mathrm{d}x^2, (\mathrm{d}x^2 = (\mathrm{d}x)^2)</script><script type="math/tex; mode=display">\mathrm{d}^3y = \mathrm{d}(\mathrm{d}^2f(x)) = d(f''(x)\mathrm{d}x^2) = f^{(3)}(x)\mathrm{d}x^3</script><p>对于任意正整数$n$,有</p><script type="math/tex; mode=display">\mathrm{d}^ny = f^{(n)}(x)\mathrm{d}x^n</script><h3 id="微分形式不变性"><a href="#微分形式不变性" class="headerlink" title="微分形式不变性"></a>微分形式不变性</h3><p><strong>概念</strong>：在微分表达式中，如果一个变量又是别的变量的函数，可以在替换变量的同时把该变量的微分替换成相应函数的微分，即<strong>微分的形式不变性</strong>，如</p><script type="math/tex; mode=display">\mathrm{d}(f(g(x))) = f'(g(x))\mathrm{d}(g(x))</script><p><strong>高阶微分不具有形式不变性</strong></p><h3 id="微分中值定理"><a href="#微分中值定理" class="headerlink" title="微分中值定理"></a>微分中值定理</h3><p><strong>费马极值定理</strong>：设函数$f(x)$在$x_0$的某邻域内有定义，如果它在$x_0$处取得极值（极大或极小）且在$x_0$处可导，则必有$f’(x_0) = 0$<br><em>证明</em>：假设极值取最大值，反证：假设$f’(x_0)&gt;0$,那么在$x_0$的某个充分小的邻域，在该邻域上恒有</p><script type="math/tex; mode=display">\cfrac{f(x) - f(x_0)}{x - x_0} > 0</script><p>所以当$x - x_0 &gt; 0$时，必有$f(x) - f(x_0) &gt; 0$，即$f(x) &gt; f(x_0)$<br><strong>罗尔(Rolle)定理</strong>：设函数$f(x)$在闭区间$[a, b]$内连续，在开区间$(a, b)$内可导，且有$f(a) = f(b)$，则开区间$(a, b)$上至少存在一个点$x_0$，使得$f’(x_0) = 0$<br><em>证明</em>：闭区间上的连续函数必定同时存在最大值和最小值，如果两极值相等，则函数值恒为常数，结论成立；当两极值不相等，最值至少有一个点和端点处的函数值不同，则极值必在开区间内取得，根据费马极值定理可得该点导数为0<br><strong>拉格朗日(Lagrange)中值定理</strong>：设函数$f(x)$在闭区间$[a, b]$上连续，在开区间$(a, b)$内可导，则存在$x_0 \in (a, b)$，使得</p><script type="math/tex; mode=display">f'(x_0) = \cfrac{f(b) - f(a)}{b - a}</script><p><strong>几何意义</strong>：闭区间上的连续函数图像，存在某个点处的切线平行于两个端点的连线<br><em>证明</em>：区间两端点直线的线性函数如下：</p><script type="math/tex; mode=display">g(x) = f(a) + \cfrac{f(b) - f(a)}{b - a}(x - a)</script><p>构造函数$L(x) = f(x) - g(x)$，显然$L(a) = L(b) = 0$，根据罗尔定理，得存在$x_0 \in (a, b)$使得$L’(x_0) = 0$，即</p><script type="math/tex; mode=display">f'(x_0) - g'(x_0) = 0</script><script type="math/tex; mode=display">f'(x_0) = g'(x_0) = \cfrac{f(b) - f(a)}{b - a}</script><p><strong>柯西(Cauchy)中值定理</strong>：设函数$f(x)$和$g(x)$在闭区间$[a, b]$上连续且在开区间$(a, b)$上可导，两个函数的导数不同时为0，$g(a) \ne g(b)$，则存在$x_0 \in (a, b)$，使得</p><script type="math/tex; mode=display">\cfrac{f'(x_0)}{g'(x_0)} = \cfrac{f(b) - f(a)}{g(b) - g(a)}</script><p><em>证明</em>：作函数</p><script type="math/tex; mode=display">h(x) = f(a) + \cfrac{f(b) - f(a)}{g(b) - g(a)}(g(x) - g(a)), C(x) = f(x) - h(x)</script><p>同拉格朗日中值定理，证$C(x)$满足罗尔定理，得证。</p><h3 id="洛必达法则"><a href="#洛必达法则" class="headerlink" title="洛必达法则"></a>洛必达法则</h3><p><strong>$\frac{0}{0}$型</strong>：设$f(x)$与$g(x)$都在$x_0$的某个空心邻域内可导，且<br>1.$\lim_{x \to x_0}f(x) = \lim_{x \to x_0}g(x) = 0$<br>2.在点$x_0$的某空心邻域内两者都可导，且$g’(x) \ne 0$<br>3.$\lim_{x \to x_0} \cfrac{f’(x)}{g’(x)} = A$，这里A可以是有限实数，也可以是无穷大或带符号的无穷大<br>则有</p><script type="math/tex; mode=display">\lim_{x \to x_0}\cfrac{f'(x)}{g(x)} = A</script><p><strong>$\frac{\infty}{\infty}$型</strong>：设$f(x)$与$g(x)$都在$x_0$右侧的某个空心邻域内可导，且<br>1.$\lim_{x \to x_0^+}f(x) = \lim_{x \to x_0^+}g(x) = \infty$<br>2.在点$x_0$的某空心邻域内两者都可导，且$g’(x) \ne 0$<br>3.$\lim_{x \to x_0^+} \cfrac{f’(x)}{g’(x)} = A$，这里A可以是有限实数，也可以是无穷大或带符号的无穷大<br>则有</p><script type="math/tex; mode=display">\lim_{x \to x_0}\cfrac{f'(x)}{g(x)} = A</script><h3 id="泰勒公式和麦克劳林公式"><a href="#泰勒公式和麦克劳林公式" class="headerlink" title="泰勒公式和麦克劳林公式"></a>泰勒公式和麦克劳林公式</h3><p><strong>泰勒(Taylor)定理</strong>：如果函数$f(x)$在$x_0$的邻域内有直到$n$阶的导函数，作<strong>泰勒多项式</strong></p><script type="math/tex; mode=display">T_n(x) = f(x_0) + f'(x_0)(x - x_0) + \cfrac{f''(x_0)}{2!}(x - x_0)^2 + ... + \cfrac{f^{(n)}(x_0)}{n!}(x - x_0)^n</script><p>则有</p><script type="math/tex; mode=display">f(x_0) = T_n(x_0), f'(x_0) = T'_n(x_0), f''(x_0) = T_n''(x_0), ..., f^{(n)}(x_0) = T_n^{(n)}(x_0)</script><p>并有下式成立</p><script type="math/tex; mode=display">f(x) = T_n(x) + o((x - x_0)^n)</script><p>这就是n阶<strong>泰勒(Taylor)公式</strong>，其中的余项$o((x - x_0)^n$称为<strong>佩亚诺余项</strong><br>当$x_0 = 0$时，泰勒公式特化成<strong>麦克劳林公式</strong></p><h3 id="基本函数的泰勒展开"><a href="#基本函数的泰勒展开" class="headerlink" title="基本函数的泰勒展开"></a>基本函数的泰勒展开</h3><div class="table-container"><table><thead><tr><th>基本函数</th><th>泰勒展开</th></tr></thead><tbody><tr><td>幂函数$f(x) = x^p (x&gt;0)$</td><td>考虑$x=1$时，$(1+x)^p=1+px+\cfrac{p(p-1)}{2!}x^2+…+\cfrac{p(p-1)…(p-n+1)}{n!}x^n+o(x^n)$</td></tr><tr><td>指数函数$f(x) = e^x$</td><td>$e^x = 1+x+\frac{1}{2!}x^2+…+\frac{1}{n!}x^n+o(x^n)$</td></tr><tr><td>对数函数$f(x) = \ln x$</td><td>考虑$x=1$时，$\ln (1+x) = x-\frac{1}{2}x^2+\frac{1}{3}x^3-…+\cfrac{(-1)^{n-1}}{n}x^n+o(x^n)$</td></tr><tr><td>正弦函数$f(x) = \sin x$</td><td>$\sin x = x - \frac{1}{3!}x^3 + \frac{1}{5!}x^5-…+\cfrac{(-1)^n}{(2n+1)!}x^{2n+1}+o(x^{2n+1})$</td></tr><tr><td>余弦函数$f(x) = \cos x$</td><td>$\cos x = 1 - \frac{1}{2!}x^2 + \frac{1}{4!}x^4-…+\cfrac{(-1)^n}{(2n)!}x^{2n}+o(x^{2n})$</td></tr></tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>极限</title>
      <link href="/2020/02/08/%E6%9E%81%E9%99%90/"/>
      <url>/2020/02/08/%E6%9E%81%E9%99%90/</url>
      
        <content type="html"><![CDATA[<h3 id="伯努利不等式（Bernoulli）"><a href="#伯努利不等式（Bernoulli）" class="headerlink" title="伯努利不等式（Bernoulli）"></a>伯努利不等式（Bernoulli）</h3><p>设实数$x\ge-1$，则对任意正整数n成立不等式</p><script type="math/tex; mode=display">(1+x)^n\ge1+nx</script><p>等号成立的充分必要条件是$x=0$或者$x=-1,n=1$<br><strong>证明</strong> 在$x\ge0$时，左边按二项式定力展开可以看到它是成立的，所以关键是如何证明x<0的情况 <br>在等式 $a^n-b^n = (a-b)(a^{n-1}+a^{n-2}b+\cdots+ab^{n-2}+b^{n-1})$<br>在式中令$a=1+x$，$b=1$便得$(1+x)^n-1=x \left[ (1+x)^{n-1}+(1+x)^{n-2}+\cdots+(1+x)+1 \right]$<br>如果$x&gt;0$，则右边中括号内的部分显然大于$n$，于是要证的不等式成立，而如果$-1&lt; x &lt; 0$，则中括号内的部分小于$n$，再与负数$x$相乘，不等式反向即证出伯努利不等式。</0的情况></p><h3 id="数列极限"><a href="#数列极限" class="headerlink" title="数列极限"></a>数列极限</h3><p>对于实数数列${a_n}$和实数$a$，如果对于任意小的正实数$\varepsilon$，都存在某一下标$N$，使得该数列在这之后的所有项(即$n&gt;N$)都满足$|a_n-a|&lt;\varepsilon$则称该数列存在极限，实数$a$称为该数列的极限。也称该数列为收敛数列，并且收敛到实数$a$，记为 <script type="math/tex">\lim_{n \to \infty}x_n = a</script><br><strong>极限唯一性</strong>：<em>如果数列$x_n$收敛，则极限唯一。</em><br><strong>保号性</strong>：<em>如果数列收敛到一个正的实数，则数列必从某向起恒保持正号，同样，若收敛到一个负的实数，则必从某项起保持负号。</em><br><strong>收敛数列的有界性</strong>：<em>收敛数列必有界。</em><br><strong>保不等性</strong>：<em>设数列$a_n$与数列$b_n$分别收敛到$A$与$B$，且当$n$充分大时恒有$a_n &lt; b_n$，则必有$A \le B$</em><br><strong>夹逼准则</strong>：<em>若三个数列$a_n、b_n、c_n$在$n$充分大时恒有$a_n \le b_n \le c_n$，并且$a_n$与$c_n$都收敛到同一极限$M$，则$b_n$亦必收敛到此极限值</em></p><h3 id="数列柯西收敛准则"><a href="#数列柯西收敛准则" class="headerlink" title="数列柯西收敛准则"></a>数列柯西收敛准则</h3><p>数列$x_n$收敛的充分必要条件是，对于任意正实数$\varepsilon$，总存在正整数$N &gt; 0$，使得任意$n_1 &gt; N$和任意$n_2 &gt; N$恒有$|x_{n1} - x_{n2} &lt; \varepsilon|$。</p><h3 id="数列的极限"><a href="#数列的极限" class="headerlink" title="数列的极限"></a>数列的极限</h3><p><strong>数列的上极限和下极限</strong>：数列$a_n$的最大聚点（可以为无穷）称为数列的上极限，记作$\overline{\lim}\limits_{n \to \infty}a_n$，而最小的聚点称为它的下极限，记作$\underline{\lim}\limits_{n \to \infty}a_n$。<br><strong>数列极限存在</strong>：数列存在极限的充分必要条件是，它的上极限与下极限相等。<br><em>聚点：对于无穷数集$A$和某个实数$x$，若$x$的任意小的领域$(x - \varepsilon, x_\varepsilon)$内都包含了$A$中的无穷多个数，则称数$x$是数集$A$的一个聚点</em><br><em>数$A$是数列$\begin{Bmatrix} a_n \end{Bmatrix}$的一个聚点的充分必要条件是，这个数列存在收敛到$A$的子数列。</em></p><h3 id="函数的极限"><a href="#函数的极限" class="headerlink" title="函数的极限"></a>函数的极限</h3><p><strong>定义</strong>：设函数$f(x)$在无穷区间$(a, +\infty)$上有定义，$A$是一个实数，如果对于任意小的正实数$\varepsilon$，总存在实数$X(&gt;a)$，使得$x &gt; X$时恒有$|f(x) - A| &lt; \varepsilon$成立，则称数$A$是函数$f(x)$在自变量趋于正无穷大时的<strong>极限</strong>，记作$\lim\limits_{x \to \infty}f(x) = A$。<br><strong>趋点极限</strong>：设函数$f(x)$在$x_0$的某空心邻域内有定义，$A$是一个实数，如果对于任意小的正实数$\varepsilon &gt; 0$，总存在另一正实数$\delta &gt; 0$，使得定义域中满足$0 &lt; |x - x_0| &lt; \delta$的数恒有$|f(x) - A &lt; \varepsilon|$，则称$A$是函数$f(x)$当自变量趋于$x_0$时的极限，记作$\lim\limits_{x \to x_o}f(x) = A$。<br><strong>单侧极限</strong>：如果函数$f(x)$在$x_0$的某个右空心邻域内有定义，$A$是一个实数，如果对于任意小的正实数$\varepsilon &gt; 0$，都存在另一个正实数$\delta &gt; 0$，使得当$x_0 &lt; x &lt; x_0 + \delta$时恒有$|f(x) - A| &lt; \delta$成立，则称$A$是函数$f(x)$在$x_0$处的<strong>右极限</strong>，记作$\lim\limits_{x \to x_0^+}f(x) = A$。把右空心邻域改为左空心邻域，把不等式$x_0 &lt; x &lt; x_0 + \delta$换成$x_0 - \delta &lt; x &lt; x_0$，就可以得到<strong>左极限</strong>的定义，记作：$\lim\limits_{x \to x_0^-}f(x) = A$。<em>显然，$\lim\limits_{x \to x_0}f(x) = A$的充分必要条件是$\lim\limits_{x \to x_0^+}f(x) = \lim\limits_{x \to x_0^-}f(x) = A$。</em></p><h3 id="函数极限的性质"><a href="#函数极限的性质" class="headerlink" title="函数极限的性质"></a>函数极限的性质</h3><p><strong>唯一性</strong>：函数极限$\lim\limits_{c \to x_0}f(x)$若存在必唯一。<br><strong>局部有界性</strong>：设函数$f(x)$在$x_0$的某空心邻域内有定义，若$\lim\limits_{x \to x_0}f(x)$存在（非无穷的有限值），则$f(x)$在$x_0$的某个空心邻域内有界。<br><strong>局部保号性</strong>：若函数$f(x)$在$x \to x_0$处的极限存在为$A$，则对于任意$r &lt; A$都存在$x_0$的某个空心邻域内，在这邻域内恒有$f(x) &gt; r$，同样，对于任意$r &gt; A$，都存在$x_0$的某空心邻域，在这邻域内恒有$f(x) &lt; r$。<br><strong>保不等式性</strong>：如果函数$f(x)$和$g(z)$都在$x_0$的某个空心邻域内有定义，且在这邻域内上恒满足$f(x) \ge g(x)$，那么如果当$x \to x_0$时两个函数分别有极限$A$和$B$，则必有$A \ge B$。<br><strong>夹逼定理</strong>：在$x_0$的某空心邻域内有定义的三个函数$f(x)、g(x)、h(x)$，如果在该邻域内恒满足$f(x) \le h(x) \le g(x)$，那么如果当时$f(x)$和$g(x)$都收敛到$A$，那么这时$h(x)$也必收敛且到收敛到$A$。<br><strong>四则运算法则</strong>：如果在$x_0$的某空心邻域内有定义的两个函数$f(x)、g(x)$在时分别收敛到$A、B$，那么由这两个函数的和、差、积、商作成的新函数也收敛，并收敛到原先两个极限值的和、差、积、商，商的情况需要满足分母不为0.<br><strong>复合函数的极限</strong>：设有如下函数极限$\lim\limits_{x \to x_0}g(x) = u_0, \lim\limits_{u \to u_0}f(u) = y_0$，且$g(x)$在$x_0$的某空心邻域上恒有$g(x) \ne u_0$，则有$\lim\limits_{x \to x_0}f(g(x)) = y_0$。<br><strong>单调有界定理</strong>：如果函数$f(x)$在$x_0$的某左空心邻域内单调递增且有上界，则函数$f(x)$在$x_0$处的左极限存在，右极限也有类似的推论。</p><h3 id="函数柯西收敛准则"><a href="#函数柯西收敛准则" class="headerlink" title="函数柯西收敛准则"></a>函数柯西收敛准则</h3><p>函数$f(x)$在$x_0$的某空心邻域内有定义，则它在该存在极限的充分必要条件是：任给正实数$\varepsilon$，恒存在另一正实数$\delta$，使得对任意满足$|x - x_0| &lt; \delta$的两个实数$x_1$和$x_2$都成立$|f(x_1) - f(x_2) &lt; \varepsilon|$。</p><h3 id="函数的连续性"><a href="#函数的连续性" class="headerlink" title="函数的连续性"></a>函数的连续性</h3><p><strong>连续与单侧连续</strong>：如果函数$f(x)$在$x_0$处存在极限，且极限值正好是该点处的函数值$f(x_0)$，则称函数在$x_0$处连续，即$\lim\limits_{x \to x_0}f(x) = f(x_0)$。如果该点处的左极限等于该点处的函数值，则称函数在该点处<strong>左连续</strong>，<strong>右连续</strong>同理。<br><strong>连续函数</strong>：如果函数在某个区间上处处连续，则称函数在这区间上连续，或者说它是这区间上的<strong>连续函数</strong></p><h3 id="间断点"><a href="#间断点" class="headerlink" title="间断点"></a>间断点</h3><p><strong>定义</strong>：如果函数在某点处不连续，则称该点是函数的一个<strong>间断点</strong>。<br><strong>可去间断点</strong>：函数在某点处不连续但存在极限，极限与函数值不相等或函数值未定义。<br><strong>跳跃间断点</strong>：存在左极限和右极限但两者不相等。<br><strong>第一类间断点</strong>：<strong>可去间断点</strong>和<strong>跳跃间断点</strong>。<br><strong>第二类间断点</strong>：至少有一个单侧极限不存在</p><h3 id="连续函数的性质"><a href="#连续函数的性质" class="headerlink" title="连续函数的性质"></a>连续函数的性质</h3><p><strong>局部有界性</strong>、<strong>局部保号性</strong>、<strong>四则运算法则</strong>同上。<br><strong>复合函数的连续性</strong>：设函数$g(x)$在$x_0$处连续，记$u_0 = g(x_0)$，若另一函数$f(u)$在$u_0$处连续，则复合函数$f(g(x))$在$x_0$处连续。</p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SCUPC I</title>
      <link href="/2019/04/26/SCUPC-I/"/>
      <url>/2019/04/26/SCUPC-I/</url>
      
        <content type="html"><![CDATA[<h3 id="SOJ-4636-Garden-Aesthetics"><a href="#SOJ-4636-Garden-Aesthetics" class="headerlink" title="SOJ 4636 Garden Aesthetics"></a><a href="http://acm.scu.edu.cn/soj/problem.action?id=4636" target="_blank" rel="noopener">SOJ 4636 Garden Aesthetics</a></h3><h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><p>给定<code>500000</code>个点，在任意4宫格中若有3个点，那么需要增加一个点填满四宫格，求所需要增加的点的个数<br>可以将点的x和y坐标拆分为两部建立二分图，每个存在的点为一条边，每一个联通块中所有未相连的边都是可以增加的点，所以对于每一个联通块来说，所需要增加点的个数等于其x坐标的个数*y坐标的个数-已存在的边数。</p><p>使用 <strong>并查集</strong> 来维护联通块，以及每个联通块中x坐标数和y坐标数以及已存在的边数。<br><br><br>对于任意一个四宫格，如果已存在3个点，那么进行合并操作后联通块一定包含有第4个点的x，y坐标，那么没有边相连的x，y坐标显然就是可以增加的点。比如下图的情况，绿色的边即为可添加的点。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">500000</span>;</span><br><span class="line"><span class="keyword">int</span> father[MAXN*<span class="number">2</span>+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> cntx[MAXN*<span class="number">2</span>+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> cnty[MAXN*<span class="number">2</span>+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> cntedge[MAXN*<span class="number">2</span>+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> tot;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    tot=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=MAXN;i++)&#123;</span><br><span class="line">        cntx[i]=<span class="number">1</span>;</span><br><span class="line">        father[i]=i;</span><br><span class="line">        cntedge[i]=cnty[i]=<span class="number">0</span>;</span><br><span class="line">    &#125;<span class="comment">//存x点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=MAXN+<span class="number">1</span>;i&lt;=MAXN*<span class="number">2</span>+<span class="number">2</span>;i++)&#123;</span><br><span class="line">        cnty[i]=<span class="number">1</span>;</span><br><span class="line">        father[i]=i;</span><br><span class="line">        cntedge[i]=cntx[i]=<span class="number">0</span>;</span><br><span class="line">    &#125;<span class="comment">//存y点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(father[x]!=x)&#123;</span><br><span class="line">        <span class="keyword">return</span> father[x]=find(father[x]);<span class="comment">//路径压缩</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">uunion</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fa=find(a);</span><br><span class="line">    <span class="keyword">int</span> fb=find(b);</span><br><span class="line">    <span class="keyword">if</span>(fa!=fb)&#123;</span><br><span class="line">        father[fa]=fb;</span><br><span class="line">        cntedge[fb]+=cntedge[fa];</span><br><span class="line">        cntx[fb]+=cntx[fa];</span><br><span class="line">        cnty[fb]+=cnty[fa];</span><br><span class="line">        <span class="comment">//一起维护边数和x，y坐标数</span></span><br><span class="line">    &#125;</span><br><span class="line">    cntedge[fb]++;<span class="comment">//每合并一组x，y即存在一条边</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a,b;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n)!=EOF)&#123;</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b);</span><br><span class="line">            uunion(a,b+MAXN+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=MAXN*<span class="number">2</span>+<span class="number">2</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(find(i)==i)</span><br><span class="line">                ans+=((<span class="keyword">long</span> <span class="keyword">long</span>)cntx[i]*(<span class="keyword">long</span> <span class="keyword">long</span>)cnty[i]-cntedge[i]);<span class="comment">//注意long long</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SCUPC B+D</title>
      <link href="/2019/04/23/SCUPC-B-D/"/>
      <url>/2019/04/23/SCUPC-B-D/</url>
      
        <content type="html"><![CDATA[<hr><h3 id="SOJ-4616-CaCO3-Tree"><a href="#SOJ-4616-CaCO3-Tree" class="headerlink" title="SOJ 4616 CaCO3 Tree"></a><a href="http://acm.scu.edu.cn/soj/problem.action?id=4616" target="_blank" rel="noopener">SOJ 4616 CaCO3 Tree</a></h3><h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><p>给定一棵n个结点的树和m条虚线边，求没有虚线连接到自身之外结点的子树个数<br>对于每一对虚线边的结点，结点到其LCA的每个点（除了LCA本身）为根结点的子树一定不符合要求统计未被标记的点的个数即是所求的子树个数<br>使用树上差分，由于LCA本身不标记，所以类似于对于边的差分，将差分数组的LCA结点-2，虚线边结点+1，从根结点dfs维护子树和，即可完成标记<br>ps:貌似卡读入</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">100005</span>;</span><br><span class="line"><span class="keyword">int</span> n,tot,a,b,n1;</span><br><span class="line"><span class="keyword">int</span> head[MAXN*<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> vis[MAXN];</span><br><span class="line"><span class="keyword">int</span> dep[MAXN];</span><br><span class="line"><span class="keyword">int</span> cnt[MAXN];</span><br><span class="line"><span class="comment">//int in[MAXN];</span></span><br><span class="line"><span class="comment">//int out[MAXN];</span></span><br><span class="line"><span class="keyword">int</span> f[MAXN][<span class="number">100</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to,next;</span><br><span class="line">&#125;edge[MAXN*<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> treenode[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="keyword">sizeof</span>(head));</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="built_in">memset</span>(dep,<span class="number">0</span>,<span class="keyword">sizeof</span>(dep));</span><br><span class="line">    <span class="built_in">memset</span>(cnt,<span class="number">0</span>,<span class="keyword">sizeof</span>(cnt));</span><br><span class="line">    tot=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    edge[tot].to=v;</span><br><span class="line">    edge[tot].next=head[u];</span><br><span class="line">    head[u]=tot++;</span><br><span class="line">    edge[tot].to=u;</span><br><span class="line">    edge[tot].next=head[v];</span><br><span class="line">    head[v]=tot++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> rt)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.push(rt);</span><br><span class="line">    f[rt][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    dep[rt]=<span class="number">1</span>;</span><br><span class="line">    vis[rt]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> fa=q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[fa];i!=<span class="number">-1</span>;i=edge[i].next)&#123;</span><br><span class="line">            <span class="keyword">int</span> v=edge[i].to;</span><br><span class="line">            <span class="keyword">if</span>(!vis[v])&#123;</span><br><span class="line">                dep[v]=dep[fa]+<span class="number">1</span>;</span><br><span class="line">                f[v][<span class="number">0</span>]=fa;</span><br><span class="line">                vis[v]=<span class="number">1</span>;</span><br><span class="line">                q.push(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cal_dep</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;(<span class="number">1</span>&lt;&lt;j)&lt;MAXN;j++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;MAXN;i++)&#123;</span><br><span class="line">            f[i][j]=f[f[i][j<span class="number">-1</span>]][j<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dep[u]&lt;dep[v])swap(u,v);</span><br><span class="line">    <span class="keyword">int</span> d=dep[u]-dep[v];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;(<span class="number">1</span>&lt;&lt;i)&lt;=MAXN;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>((<span class="number">1</span>&lt;&lt;i)&amp;d)u=f[u][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(u!=v)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=(<span class="keyword">int</span>)<span class="built_in">log</span>(MAXN);i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(f[u][i]!=f[v][i])&#123;</span><br><span class="line">                u=f[u][i];</span><br><span class="line">                v=f[v][i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[u][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">vis[u]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i!=<span class="number">-1</span>;i=edge[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> v=edge[i].to;</span><br><span class="line">        <span class="keyword">if</span>(!vis[v])&#123;</span><br><span class="line">            dfs(v);</span><br><span class="line">            cnt[u]+=cnt[v];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n)&#123;</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b);</span><br><span class="line">            addedge(a,b);</span><br><span class="line">        &#125;</span><br><span class="line">        bfs(<span class="number">1</span>);</span><br><span class="line">        cal_dep();</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;n1;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n1;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b);</span><br><span class="line">            cnt[a]++;</span><br><span class="line">            cnt[b]++;</span><br><span class="line">            <span class="keyword">int</span> k=lca(a,b);</span><br><span class="line">            cnt[k]-=<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">        dfs(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!cnt[i])&#123;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="SOJ-4631-CRY-cry"><a href="#SOJ-4631-CRY-cry" class="headerlink" title="SOJ 4631 CRY cry"></a><a href="http://acm.scu.edu.cn/soj/problem.action?id=4631" target="_blank" rel="noopener">SOJ 4631 CRY cry</a></h3><h4 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h4><p>对于给出的每一个1操作，将给的点分成同一种类的三个值，操作0对结果无影响，将所有点按照值的大小排序，使用双指针（不符合要求右指针右移，符合要求左指针右移到不符合要求为止）跑完整个序列，维护最小值,判断条件保持线性</p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">100005</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">  <span class="keyword">int</span> index;</span><br><span class="line">  <span class="keyword">int</span> val;</span><br><span class="line">&#125;node[MAXN*<span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Node a,Node b)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a.val&lt;b.val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> vis[MAXN*<span class="number">3</span>];</span><br><span class="line"><span class="keyword">int</span> n,a,b,c,d;</span><br><span class="line"><span class="keyword">int</span> tot,tott,zero_cnt,que;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n)&#123;</span><br><span class="line">    tot=<span class="number">0</span>;</span><br><span class="line">    tott=<span class="number">0</span>;</span><br><span class="line">    zero_cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">      <span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b;</span><br><span class="line">      <span class="keyword">if</span>(b==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;c&gt;&gt;d;</span><br><span class="line">        node[tot].index=tott;</span><br><span class="line">        node[tot++].val=a;</span><br><span class="line">        node[tot].index=tott;</span><br><span class="line">        node[tot++].val=a+c;</span><br><span class="line">        node[tot].index=tott++;</span><br><span class="line">        node[tot++].val=a-d;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span>&#123;</span><br><span class="line">        zero_cnt++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(node,node+tot,cmp);</span><br><span class="line">    <span class="comment">//cout&lt;&lt;node[0].val&lt;&lt;endl;</span></span><br><span class="line">    <span class="keyword">if</span>(zero_cnt==n)<span class="built_in">cout</span>&lt;&lt;<span class="number">0</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">int</span> flag=<span class="number">0</span>;</span><br><span class="line">    que=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;tott;k++)&#123;</span><br><span class="line">  vis[node[k].index]++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;tott;k++)&#123;</span><br><span class="line">  <span class="keyword">if</span>(!vis[k])&#123;</span><br><span class="line">  flag=<span class="number">1</span>;</span><br><span class="line">  que++;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(flag==<span class="number">0</span>)&#123;</span><br><span class="line">  ans=node[tott<span class="number">-1</span>].val-node[<span class="number">0</span>].val;</span><br><span class="line">  &#125;</span><br><span class="line">  j=tott<span class="number">-1</span>;</span><br><span class="line">  i=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(j&lt;tot)&#123;</span><br><span class="line">  <span class="keyword">while</span>(flag==<span class="number">1</span>&amp;&amp;j&lt;tot)&#123;</span><br><span class="line">  j++;</span><br><span class="line">  vis[node[j].index]++;</span><br><span class="line">  <span class="keyword">if</span>(vis[node[j].index]==<span class="number">1</span>)que--;</span><br><span class="line">  <span class="keyword">if</span>(que==<span class="number">0</span>)&#123;</span><br><span class="line">  flag=<span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(flag==<span class="number">0</span>&amp;&amp;j&lt;tot)&#123;</span><br><span class="line">  i++;</span><br><span class="line">  vis[node[i<span class="number">-1</span>].index]--;</span><br><span class="line">  <span class="keyword">if</span>(vis[node[i<span class="number">-1</span>].index]==<span class="number">0</span>)que++;</span><br><span class="line">  <span class="keyword">if</span>(que&gt;<span class="number">0</span>)&#123;</span><br><span class="line">  flag=<span class="number">1</span>;</span><br><span class="line">  ans=min(ans,node[j].val-node[i<span class="number">-1</span>].val);</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>支持向量机</title>
      <link href="/2019/04/19/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/"/>
      <url>/2019/04/19/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<h3 id="SVM简介"><a href="#SVM简介" class="headerlink" title="SVM简介"></a>SVM简介</h3><p>支持向量机(Support Vector Machine)是Cortes和Vapnik于1995年首先提出的，它在解决小样本、非线性及高维模式识别中表现出许多特有的优势，并能够推广应用到函数拟合等其他机器学习问题中。<br>支持向量机方法是建立在统计学习理论的VC 维理论和结构风险最小原理基础上的，根据有限的样本信息在模型的复杂性（即对特定训练样本的学习精度，Accuracy）和学习能力（即无错误地识别任意样本的能力）之间寻求最佳折衷，以期获得最好的推广能力。<br><br></p><h3 id="线性分类"><a href="#线性分类" class="headerlink" title="线性分类"></a>线性分类</h3><p>给定训练样本集 $ D=((x_1,y_1),(x_2,y_2),…,(x_m,y_m)),y_i\in\{-1,1\} $，线性分类器基于训练样本集D找到一个超平面 $ f(x)=W^Tx+b$ 区分两类数据。<br>当$ f(x)&gt;0 $时表示$ y=1 $的点，$ f(x)<0 $时表示$ y="-1" $的点，当$ f(x)="0" $时，表示该点在超平面上。当超平面距离两边的数据间距越大，则表示该超平面抗干扰性越好 <br></0></p><h3 id="支持向量"><a href="#支持向量" class="headerlink" title="支持向量"></a>支持向量</h3><p><br></p><script type="math/tex; mode=display">{w^Tx_i+b\geq1,y_i=1\atop w^Tx_i+b\leq-1,y_i=-1}</script><p><em>支持向量</em> 就是使得上式等号成立的，最靠近两条虚边界线的向量。<br>我们可以通过计算得到每一样本点$x$到超平面的距离为 $ r=\frac{|w^Tx+b|}{||w||} $<br>支持向量满足上述等式，由$w^Tx_0+b=0$($x_0$为垂点)可得 $ r=\frac{|w^Tx+b|}{||w||} $<br>推出 $ r=\frac{2}{||w||} $<br>得SVM的基本型</p><script type="math/tex; mode=display">max\frac{2}{||w||}\atop{s.t.y_i(w^Tx_i+b)\geq1,i=1,2,...,m}</script><p>等价于</p><script type="math/tex; mode=display">min\frac{1}{2}||w||^2\atop{s.t.y_i(w^Tx_i+b\geq,i=1,2,...m)}</script><p>使用拉格朗日乘数法求解</p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CodeForces 933A A Twisty Movement 题解</title>
      <link href="/2019/04/17/CodeForces_933A/"/>
      <url>/2019/04/17/CodeForces_933A/</url>
      
        <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>有一个由1和2构成的序列，你可以选择一个区间<a href="1≤ l ≤ r ≤ n">l,r</a>翻转，即这段区间就变成ar,ar-1,…,al+1,al。使得新序列中的non-decreasing subsequence最长。<br>一个长为k的non-decreasing subsequence是，一个满足下标p1 &lt; p2 &lt; … &lt; pk并且，ap1 ≤ ap2 ≤ … ≤ apk的子序列。</p><h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>第一行一个整数n (1 ≤ n ≤ 2000)，表示原串的长度。<br>第二行包含n个整数，表示a1, a2, …, an (1 ≤ ai ≤ 2, i = 1, 2, …, n)。</p><h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>Print a single integer, which means the maximum possible length of the longest non-decreasing subsequence of the new sequence.</p><h2 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h2><p>Input<br><code>4</code><br><code>1 2 1 2</code><br>Output<br><code>4</code><br>Input<br><code>10</code><br><code>1 1 2 2 2 1 1 2 2 1</code><br>Output<br><code>9</code></p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_N=<span class="number">2005</span>;</span><br><span class="line"><span class="keyword">int</span> n,ans;</span><br><span class="line"><span class="keyword">int</span> pre[MAX_N],nex[MAX_N],dp[MAX_N],a[MAX_N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">dp[i]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;i;++j)</span><br><span class="line"><span class="keyword">if</span>(a[j]&lt;=a[i]&amp;&amp;dp[j]+<span class="number">1</span>&gt;dp[i])</span><br><span class="line">                dp[i]=dp[j]+<span class="number">1</span>;</span><br><span class="line">pre[i]=max(dp[i],pre[i<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">dp[i]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=n;j&gt;i;j--)</span><br><span class="line"><span class="keyword">if</span>(a[j]&gt;=a[i]&amp;&amp;dp[j]+<span class="number">1</span>&gt;dp[i])</span><br><span class="line">                dp[i]=dp[j]+<span class="number">1</span>;</span><br><span class="line">nex[i]=max(dp[i],nex[i+<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        ans=max(ans,pre[i]+nex[i+<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>由于问题给出的数列只有1，2两个元素，所以我们所求的区间翻转后的LIS必然为若干个1接上若干个2.所以考虑该LIS在区间翻转前的状态一定为若干个1接上若干个2再接上若干个1和若干个2.所以要求翻转后的LIS的长度，就可以将整个序列分为两部分，前半部分求其正向非减的最大长度，后半部分求其逆向非增的最大长度，将其求和即可得到翻转后的LIS长度，最后求最大值即可。</p><h2 id="题目地址"><a href="#题目地址" class="headerlink" title="题目地址"></a>题目地址</h2><p><a href="http://codeforces.com/problemset/problem/933/A" target="_blank" rel="noopener">CodeForces 933A A Twisty Movement</a></p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
