[{"title":"SCUPC I","url":"/2019/04/26/SCUPC-I/","content":"### [SOJ 4636 Garden Aesthetics](http://acm.scu.edu.cn/soj/problem.action?id=4636)\n#### 题意\n给定`500000`个点，在任意4宫格中若有3个点，那么需要增加一个点填满四宫格，求所需要增加的点的个数\n可以将点的x和y坐标拆分为两部建立二分图，每个存在的点为一条边，每一个联通块中所有未相连的边都是可以增加的点，所以对于每一个联通块来说，所需要增加点的个数等于其x坐标的个数*y坐标的个数-已存在的边数。\n\n使用 **并查集** 来维护联通块，以及每个联通块中x坐标数和y坐标数以及已存在的边数。\n<br>\n对于任意一个四宫格，如果已存在3个点，那么进行合并操作后联通块一定包含有第4个点的x，y坐标，那么没有边相连的x，y坐标显然就是可以增加的点。比如下图的情况，绿色的边即为可添加的点。\n\n#### 代码\n```C++\n#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nconst int MAXN=500000;\nint father[MAXN*2+5];\nint n;\nint cntx[MAXN*2+5];\nint cnty[MAXN*2+5];\nint cntedge[MAXN*2+5];\nint tot;\nvoid init(){\n    tot=0;\n    for(int i=0;i<=MAXN;i++){\n        cntx[i]=1;\n        father[i]=i;\n        cntedge[i]=cnty[i]=0;\n    }//存x点\n    for(int i=MAXN+1;i<=MAXN*2+2;i++){\n        cnty[i]=1;\n        father[i]=i;\n        cntedge[i]=cntx[i]=0;\n    }//存y点\n}\nint find(int x){\n    if(father[x]!=x){\n        return father[x]=find(father[x]);//路径压缩\n    }\n    else return x;\n}\nvoid uunion(int a,int b){\n    int fa=find(a);\n    int fb=find(b);\n    if(fa!=fb){\n        father[fa]=fb;\n        cntedge[fb]+=cntedge[fa];\n        cntx[fb]+=cntx[fa];\n        cnty[fb]+=cnty[fa];\n        //一起维护边数和x，y坐标数\n    }\n    cntedge[fb]++;//每合并一组x，y即存在一条边\n}\nint main(){\n    int a,b;\n    while(scanf(\"%d\",&n)!=EOF){\n        init();\n        for(int i=0;i<n;i++){\n            scanf(\"%d%d\",&a,&b);\n            uunion(a,b+MAXN+1);\n        }\n        long long ans=0;\n        for(int i=0;i<=MAXN*2+2;i++){\n            if(find(i)==i)\n                ans+=((long long)cntx[i]*(long long)cnty[i]-cntedge[i]);//注意long long\n        }\n        printf(\"%lld\\n\",ans);\n    }\n    return 0;\n}\n```","categories":["题解"]},{"title":"SCUPC B+D","url":"/2019/04/23/SCUPC-B-D/","content":"---\n### [SOJ 4616 CaCO3 Tree](http://acm.scu.edu.cn/soj/problem.action?id=4616)\n#### 题意\n给定一棵n个结点的树和m条虚线边，求没有虚线连接到自身之外结点的子树个数\n对于每一对虚线边的结点，结点到其LCA的每个点（除了LCA本身）为根结点的子树一定不符合要求统计未被标记的点的个数即是所求的子树个数\n使用树上差分，由于LCA本身不标记，所以类似于对于边的差分，将差分数组的LCA结点-2，虚线边结点+1，从根结点dfs维护子树和，即可完成标记\nps:貌似卡读入\n#### 代码\n```C++\n#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#include<queue>\nusing namespace std;\nconst int MAXN=100005;\nint n,tot,a,b,n1;\nint head[MAXN*2];\nint vis[MAXN];\nint dep[MAXN];\nint cnt[MAXN];\n//int in[MAXN];\n//int out[MAXN];\nint f[MAXN][100];\nstruct Edge{\n    int to,next;\n}edge[MAXN*2];\nint treenode[MAXN];\nvoid init(){\n    memset(head,-1,sizeof(head));\n    memset(vis,0,sizeof(vis));\n    memset(dep,0,sizeof(dep));\n    memset(cnt,0,sizeof(cnt));\n    tot=0;\n}\nvoid addedge(int u,int v){\n    edge[tot].to=v;\n    edge[tot].next=head[u];\n    head[u]=tot++;\n    edge[tot].to=u;\n    edge[tot].next=head[v];\n    head[v]=tot++;\n}\nvoid bfs(int rt){\n    memset(vis,0,sizeof(vis));\n    queue<int> q;\n    q.push(rt);\n    f[rt][0]=0;\n    dep[rt]=1;\n    vis[rt]=1;\n    while(!q.empty()){\n        int fa=q.front();\n        q.pop();\n        for(int i=head[fa];i!=-1;i=edge[i].next){\n            int v=edge[i].to;\n            if(!vis[v]){\n                dep[v]=dep[fa]+1;\n                f[v][0]=fa;\n                vis[v]=1;\n                q.push(v);\n            }\n        }\n    }\n}\nvoid cal_dep(){\n    for(int j=1;(1<<j)<MAXN;j++){\n        for(int i=1;i<MAXN;i++){\n            f[i][j]=f[f[i][j-1]][j-1];\n        }\n    }\n}\nint lca(int u,int v){\n    if(dep[u]<dep[v])swap(u,v);\n    int d=dep[u]-dep[v];\n    for(int i=0;(1<<i)<=MAXN;i++){\n        if((1<<i)&d)u=f[u][i];\n    }\n    if(u!=v){\n        for(int i=(int)log(MAXN);i>=0;i--){\n            if(f[u][i]!=f[v][i]){\n                u=f[u][i];\n                v=f[v][i];\n            }\n        }\n        return f[u][0];\n    }\n    else return u;\n}\nvoid dfs(int u){\n\tvis[u]=1;\n    for(int i=head[u];i!=-1;i=edge[i].next){\n        int v=edge[i].to;\n        if(!vis[v]){\n            dfs(v);\n            cnt[u]+=cnt[v];\n        }\n    }\n}\nint main(){\n    while(cin>>n){\n        init();\n        for(int i=0;i<n-1;i++){\n            scanf(\"%d%d\",&a,&b);\n            addedge(a,b);\n        }\n        bfs(1);\n        cal_dep();\n        cin>>n1;\n        for(int i=0;i<n1;i++){\n            scanf(\"%d%d\",&a,&b);\n            cnt[a]++;\n            cnt[b]++;\n            int k=lca(a,b);\n            cnt[k]-=2;\n        }\n        memset(vis,0,sizeof(vis));\n        dfs(1);\n        int ans=0;\n        for(int i=1;i<=n;i++){\n            if(!cnt[i]){\n                ans++;\n            }\n        }\n        printf(\"%d\\n\",ans);\n    }\n    return 0;\n}\n```\n---\n### [SOJ 4631 CRY cry](http://acm.scu.edu.cn/soj/problem.action?id=4631)\n#### 题意\n对于给出的每一个1操作，将给的点分成同一种类的三个值，操作0对结果无影响，将所有点按照值的大小排序，使用双指针（不符合要求右指针右移，符合要求左指针右移到不符合要求为止）跑完整个序列，维护最小值,判断条件保持线性\n#### 代码\n```C++\n#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\nusing namespace std;\nconst int MAXN=100005;\nstruct Node{\n  int index;\n  int val;\n}node[MAXN*3];\nbool cmp(Node a,Node b){\n  return a.val<b.val;\n}\nint vis[MAXN*3];\nint n,a,b,c,d;\nint tot,tott,zero_cnt,que;\nint main(){\n  while(cin>>n){\n    tot=0;\n    tott=0;\n    zero_cnt=0;\n    for(int i=0;i<n;i++){\n      cin>>a>>b;\n      if(b==1){\n        cin>>c>>d;\n        node[tot].index=tott;\n        node[tot++].val=a;\n        node[tot].index=tott;\n        node[tot++].val=a+c;\n        node[tot].index=tott++;\n        node[tot++].val=a-d;\n      }\n      else{\n        zero_cnt++;\n      }\n    }\n    sort(node,node+tot,cmp);\n    //cout<<node[0].val<<endl;\n    if(zero_cnt==n)cout<<0<<endl;\n    else{\n    \tint ans=0x3f3f3f3f;\n    \tint i,j;\n    \tint flag=0;\n    \tque=0;\n    \tmemset(vis,0,sizeof(vis));\n\t\tfor(int k=0;k<tott;k++){\n\t  \t\tvis[node[k].index]++;\n\t  \t}\n\t  \tfor(int k=0;k<tott;k++){\n\t  \t\tif(!vis[k]){\n\t  \t\t\tflag=1;\n\t  \t\t\tque++;\n\t\t  \t}\n\t  \t}\n\t  \tif(flag==0){\n\t  \t\tans=node[tott-1].val-node[0].val;\n\t  \t}\t\n\t  \tj=tott-1;\n\t  \ti=0;\n\t  \twhile(j<tot){\n\t  \t\twhile(flag==1&&j<tot){\n\t  \t\t\tj++;\n\t  \t\t\tvis[node[j].index]++;\n\t  \t\t\tif(vis[node[j].index]==1)que--;\n\t  \t\t\tif(que==0){\n\t  \t\t\t\tflag=0;\n\t\t\t  \t}\n\t\t  \t}\n\t\t  \twhile(flag==0&&j<tot){\n\t\t  \t\ti++;\n\t\t  \t\tvis[node[i-1].index]--;\n\t\t  \t\tif(vis[node[i-1].index]==0)que++;\n\t\t  \t\tif(que>0){\n\t\t  \t\t\tflag=1;\n\t\t  \t\t\tans=min(ans,node[j].val-node[i-1].val);\t\n\t\t\t  \t}\n\t\t  \t}\n\t  \t} \n\t  \tcout<<ans<<endl;\t\n\t}\t\n  }\t\n  return 0;\n}\n```","categories":["题解"]},{"title":"支持向量机","url":"/2019/04/19/支持向量机/","content":"### SVM简介\n支持向量机(Support Vector Machine)是Cortes和Vapnik于1995年首先提出的，它在解决小样本、非线性及高维模式识别中表现出许多特有的优势，并能够推广应用到函数拟合等其他机器学习问题中。\n支持向量机方法是建立在统计学习理论的VC 维理论和结构风险最小原理基础上的，根据有限的样本信息在模型的复杂性（即对特定训练样本的学习精度，Accuracy）和学习能力（即无错误地识别任意样本的能力）之间寻求最佳折衷，以期获得最好的推广能力。\n<br>\n### 线性分类\n给定训练样本集 $ D=((x_1,y_1),(x_2,y_2),...,(x_m,y_m)),y_i\\in\\{-1,1\\} $，线性分类器基于训练样本集D找到一个超平面 $ f(x)=W^Tx+b$ 区分两类数据。\n当$ f(x)>0 $时表示$ y=1 $的点，$ f(x)<0 $时表示$ y=-1 $的点，当$ f(x)=0 $时，表示该点在超平面上。当超平面距离两边的数据间距越大，则表示该超平面抗干扰性越好\n<br>\n### 支持向量\n<br>\n\n$$ {w^Tx_i+b\\geq1,y_i=1\\atop w^Tx_i+b\\leq-1,y_i=-1} $$\n\n*支持向量* 就是使得上式等号成立的，最靠近两条虚边界线的向量。\n我们可以通过计算得到每一样本点$x$到超平面的距离为 $ r=\\frac{|w^Tx+b|}{||w||} $\n支持向量满足上述等式，由$w^Tx_0+b=0$($x_0$为垂点)可得 $ r=\\frac{|w^Tx+b|}{||w||} $\n推出 $ r=\\frac{2}{||w||} $\n得SVM的基本型\n$$ max\\frac{2}{||w||}\\atop{s.t.y_i(w^Tx_i+b)\\geq1,i=1,2,...,m} $$\n等价于\n$$ min\\frac{1}{2}||w||^2\\atop{s.t.y_i(w^Tx_i+b\\geq,i=1,2,...m)} $$\n使用拉格朗日乘数法求解","categories":["机器学习"]},{"title":"线段树模板","url":"/2019/04/18/线段树模板/","content":"## 定义\n\n**线段树**是一种**二叉搜索树**，与区间树相似，它将一个区间划分成一些单元区间，每个单元区间对应线段树中的一个叶结点。使用线段树可以快速的查找某一个节点在若干条线段中出现的次数，时间复杂度为**O(logN）**。而未优化的空间复杂度为**2N**，实际应用时**一般**还要开**4N**的数组以免越界，因此有时需要[离散化](https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#13-待办事宜-todo-列表//写好后替换)让空间压缩。\n<br>\n## 线段树概述\n假设有编号从1到n的n个点，每个点都存了一些信息，用[L,R]表示下标从L到R的这些点。\n线段树的用处就是，对编号连续的一些点进行修改或者统计操作，修改和统计的复杂度都是**O(log2(n))**.\n线段树的原理，就是，将[1,n]分解成若干特定的子区间(数量不超过4*n),然后，将每个区间[L,R]都分解为\n少量特定的子区间，通过对这些少量子区间的修改或者统计，来实现快速对[L,R]的修改或者统计。\n由此看出，用线段树统计的东西，必须符合**区间加法**，否则，不可能通过分成的子区间来得到[L,R]的统计结果。\n符合区间加法的例子：\n    数字之和——总数字之和 = 左区间数字之和 + 右区间数字之和\n**最大公因数** (GCD)——总GCD = gcd( 左区间GCD , 右区间GCD );\n最大值——总最大值=max(左区间最大值，右区间最大值)\n不符合区间加法的例子：\n众数——只知道左右区间的众数，没法求总区间的众数\n01序列的最长连续零——只知道左右区间的最长连续零，没法知道总的最长连续零\n一个问题，只要能化成对一些连续点的修改和统计问题，基本就可以用线段树来解决了。\n<br>\n\n## 模板代码\n```C++\n#define maxn 100007  //元素总个数\n#define ls l,m,rt<<1\n#define rs m+1,r,rt<<1|1\nint Sum[maxn<<2],Add[maxn<<2];//Sum求和，Add为懒惰标记 \nint A[maxn],n;//存原数组数据下标[1,n] \n//PushUp函数更新节点信息 ，这里是求和\nvoid PushUp(int rt){Sum[rt]=Sum[rt<<1]+Sum[rt<<1|1];}\n//Build函数建树 \nvoid Build(int l,int r,int rt){ //l,r表示当前节点区间，rt表示当前节点编号\n\tif(l==r) {//若到达叶节点 \n\t\tSum[rt]=A[l];//储存数组值 \n\t\treturn;\n\t}\n\tint m=(l+r)>>1;\n\t//左右递归 \n\tBuild(l,m,rt<<1);\n\tBuild(m+1,r,rt<<1|1);\n\t//更新信息 \n\tPushUp(rt);\n}\nvoid Update(int L,int C,int l,int r,int rt){//l,r表示当前节点区间，rt表示当前节点编号\n\tif(l==r){//到叶节点，修改 \n\t\tSum[rt]+=C;\n\t\treturn;\n\t}\n\tint m=(l+r)>>1;\n\t//根据条件判断往左子树调用还是往右 \n\tif(L <= m) Update(L,C,l,m,rt<<1);\n\telse       Update(L,C,m+1,r,rt<<1|1);\n\tPushUp(rt);//子节点更新了，所以本节点也需要更新信息 \n} \nvoid Update(int L,int R,int C,int l,int r,int rt){//L,R表示操作区间，l,r表示当前节点区间，rt表示当前节点编号 \n\tif(L <= l && r <= R){//如果本区间完全在操作区间[L,R]以内 \n\t\tSum[rt]+=C*(r-l+1);//更新数字和，向上保持正确\n\t\tAdd[rt]+=C;//增加Add标记，表示本区间的Sum正确，子区间的Sum仍需要根据Add的值来调整\n\t\treturn ; \n\t}\n\tint m=(l+r)>>1;\n\tPushDown(rt,m-l+1,r-m);//下推标记\n\t//这里判断左右子树跟[L,R]有无交集，有交集才递归 \n\tif(L <= m) Update(L,R,C,l,m,rt<<1);\n\tif(R >  m) Update(L,R,C,m+1,r,rt<<1|1); \n\tPushUp(rt);//更新本节点信息 \n} \nvoid PushDown(int rt,int ln,int rn){\n\t//ln,rn为左子树，右子树的数字数量。 \n\tif(Add[rt]){\n\t\t//下推标记 \n\t\tAdd[rt<<1]+=Add[rt];\n\t\tAdd[rt<<1|1]+=Add[rt];\n\t\t//修改子节点的Sum使之与对应的Add相对应 \n\t\tSum[rt<<1]+=Add[rt]*ln;\n\t\tSum[rt<<1|1]+=Add[rt]*rn;\n\t\t//清除本节点标记 \n\t\tAdd[rt]=0;\n\t}\n}\nint Query(int L,int R,int l,int r,int rt){//L,R表示操作区间，l,r表示当前节点区间，rt表示当前节点编号\n\tif(L <= l && r <= R){\n\t\t//在区间内，直接返回 \n\t\treturn Sum[rt];\n\t}\n\tint m=(l+r)>>1;\n\t//下推标记，否则Sum可能不正确\n\tPushDown(rt,m-l+1,r-m); \n\t\n\t//累计答案\n\tint ANS=0;\n\tif(L <= m) ANS+=Query(L,R,l,m,rt<<1);\n\tif(R >  m) ANS+=Query(L,R,m+1,r,rt<<1|1);\n\treturn ANS;\n} \n```\n***函数调用***\n```C++\n\t//建树 \n\tBuild(1,n,1); \n\t//点修改\n\tUpdate(L,C,1,n,1);\n\t//区间修改 \n\tUpdate(L,R,C,1,n,1);\n\t//区间查询 \n\tint ANS=Query(L,R,1,n,1)\n```\n以上内容改编于[岩之痕](https://blog.csdn.net/zearot/article/details/48299459)的博客\n\n## *例题*\n### [POJ 3368 Frequent Values](http://poj.org/problem?id=3368)\n\n*AC代码*\n```C++\n#include<cstdio>\n#include<iostream>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nint n, q;\nconst int maxn = 100000 + 10;\nint A[maxn];\nint L[maxn<<2], Lc[maxn<<2], R[maxn<<2], Rc[maxn<<2], S[maxn<<2];\nvoid Build(int p, int l, int r){\n\tif(l == r){\n\t\tL[p] = R[p] = A[l];\n\t\tLc[p] = Rc[p] = 1;\n\t\tS[p] = 1;\n\t\treturn;\n\t}\n\tint mid = (l + r) >> 1;\n\tBuild(p<<1, l, mid);\n\tBuild(p<<1|1, mid+1, r);//P<<1|1 = 2*p+1\n\tint temp = 0;\n\tif(R[p<<1] == L[p<<1|1]) \n\t\ttemp = Rc[p<<1] + Lc[p<<1|1];\n\ttemp = max(temp, S[p<<1]);\n\tS[p] = max(temp, S[p<<1|1]);\n\tL[p] = L[p<<1], R[p] = R[p<<1|1];\n\tif(L[p<<1] == L[p<<1|1]) \n\t\tLc[p] = Lc[p<<1] + Lc[p<<1|1];\n\telse Lc[p] = Lc[p<<1];\n\tif(R[p<<1] == R[p<<1|1])\n\t\tRc[p] = Rc[p<<1] + Rc[p<<1|1];\n\telse Rc[p] = Rc[p<<1|1];\n}\nint Query(int p, int l, int r, int a, int b){\n\tif(l >= a && r <= b) \n\t\treturn S[p];\n\tint mid = (l + r) >> 1;\n\tint x = 0, y = 0;\n\tif(a <= mid)\n\t\t x = Query(p<<1, l, mid, a, b);\n\tif(b > mid) \n\t\ty = Query(p<<1|1, mid+1, r, a, b);\n\tint result = max(x, y);\n\tif(x > 0 && y > 0 && R[p<<1] == L[p<<1|1]){ //中间节点可以合并的情况\n\t\tint temp = min(Rc[p<<1], mid-a+1);\n\t\ttemp += min(Lc[p<<1|1], b-mid);\n\t\tresult = max(temp, result);\n\t}\n\treturn result;\n}\nint main(){\n\tscanf(\"%d\",&n);\n\twhile(n!=0){\n\t\tscanf(\"%d\", &q);\n\t\tfor(int i= 1; i<= n; i++)\n\t\t\tscanf(\"%d\", &A[i]);\n\t\tBuild(1, 1, n);\n\t\twhile(q--){\n\t\t\tint a, b;\n\t\t\tscanf(\"%d %d\", &a, &b);\n\t\t\tprintf(\"%d\\n\", Query(1, 1, n, a, b));\n\t\t}\n\t\tscanf(\"%d\",&n);\n\t}\n\treturn 0;\n}\n```\n\n\n\n\n","categories":["算法"]},{"title":"CodeForces 933A A Twisty Movement 题解","url":"/2019/04/17/CodeForces_933A/","content":"## Description\n有一个由1和2构成的序列，你可以选择一个区间[l,r](1≤ l ≤ r ≤ n)翻转，即这段区间就变成ar,ar-1,…,al+1,al。使得新序列中的non-decreasing subsequence最长。\n一个长为k的non-decreasing subsequence是，一个满足下标p1 < p2 < … < pk并且，ap1 ≤ ap2 ≤ … ≤ apk的子序列。\n## Input\n第一行一个整数n (1 ≤ n ≤ 2000)，表示原串的长度。\n第二行包含n个整数，表示a1, a2, …, an (1 ≤ ai ≤ 2, i = 1, 2, …, n)。\n## Output\nPrint a single integer, which means the maximum possible length of the longest non-decreasing subsequence of the new sequence.\n## Examples\n\nInput\n`4`\n`1 2 1 2`\nOutput\n`4`\nInput\n`10`\n`1 1 2 2 2 1 1 2 2 1`\nOutput\n`9`\n## AC代码\n```C++\n#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n#define LL long long\nconst int MAX_N=2005;\nint n,ans;\nint pre[MAX_N],nex[MAX_N],dp[MAX_N],a[MAX_N];\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n        scanf(\"%d\",&a[i]);\n\tfor(int i=1;i<=n;i++){\n\t\tdp[i]=1;\n\t\tfor(int j=1;j<i;++j)\n\t\t\tif(a[j]<=a[i]&&dp[j]+1>dp[i])\n                dp[i]=dp[j]+1;\n\t\tpre[i]=max(dp[i],pre[i-1]);\n\t}\n\tfor(int i=n;i>=1;i--){\n\t\tdp[i]=1;\n\t\tfor(int j=n;j>i;j--)\n\t\t\tif(a[j]>=a[i]&&dp[j]+1>dp[i])\n                dp[i]=dp[j]+1;\n\t\tnex[i]=max(dp[i],nex[i+1]);\n\t}\n\tfor(int i=1;i<=n;i++)\n        ans=max(ans,pre[i]+nex[i+1]);\n\tprintf(\"%d\",ans);\n\treturn 0;\n}\n```\n## 题解\n由于问题给出的数列只有1，2两个元素，所以我们所求的区间翻转后的LIS必然为若干个1接上若干个2.所以考虑该LIS在区间翻转前的状态一定为若干个1接上若干个2再接上若干个1和若干个2.所以要求翻转后的LIS的长度，就可以将整个序列分为两部分，前半部分求其正向非减的最大长度，后半部分求其逆向非增的最大长度，将其求和即可得到翻转后的LIS长度，最后求最大值即可。\n## 题目地址\n[CodeForces 933A A Twisty Movement](http://codeforces.com/problemset/problem/933/A)\n\n\n\n\n","categories":["题解"]}]